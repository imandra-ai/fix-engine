<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser (core_pp.Parser_utils.Parser)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">core_pp</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Parser_utils.Parser</span></h1></header><div class="doc"><p>The Parser module collects an API of parser-combinators for parsing FIX
messages into OCaml types. Each combinator takes a continuation function
that returns a <code class="code">( 'a Parser.t * msg )</code> type</p></div><div class="spec type" id="type-msg"><a href="#type-msg" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>msg</code><code><span class="keyword"> = </span>(string<span class="keyword"> * </span>string) list</code><code></code></div><div class="doc"><p>Type alias for a FIX message -- we assyme it is a list of string parirs</p></div></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a t</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-t.ParseSuccess" class="anchored"><td class="def constructor"><a href="#type-t.ParseSuccess" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ParseSuccess</span><span class="keyword"> of </span><span class="type-var">'a</span></code></td></tr><tr id="type-t.UnknownMessageTag" class="anchored"><td class="def constructor"><a href="#type-t.UnknownMessageTag" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">UnknownMessageTag</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.RequiredTagMissing" class="anchored"><td class="def constructor"><a href="#type-t.RequiredTagMissing" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">RequiredTagMissing</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.DuplicateTag" class="anchored"><td class="def constructor"><a href="#type-t.DuplicateTag" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">DuplicateTag</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.WrongValueFormat" class="anchored"><td class="def constructor"><a href="#type-t.WrongValueFormat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">WrongValueFormat</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.UndefinedTag" class="anchored"><td class="def constructor"><a href="#type-t.UndefinedTag" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">UndefinedTag</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.EmptyValue" class="anchored"><td class="def constructor"><a href="#type-t.EmptyValue" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">EmptyValue</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.IncorrectNumInGroupCount" class="anchored"><td class="def constructor"><a href="#type-t.IncorrectNumInGroupCount" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">IncorrectNumInGroupCount</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.RepeatingGroupOutOfOrder" class="anchored"><td class="def constructor"><a href="#type-t.RepeatingGroupOutOfOrder" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">RepeatingGroupOutOfOrder</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-t.GarbledMessage" class="anchored"><td class="def constructor"><a href="#type-t.GarbledMessage" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">GarbledMessage</span></code></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec val" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>A standard monadic bind operator for the Parser.t type</p></div></div><div class="spec val" id="val-(&gt;|&gt;=)"><a href="#val-(&gt;|&gt;=)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(&gt;|&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list</code></div><div class="doc"><p>The modified bind operator that applies a function that
returns <code class="code">( 'a Parser.t * msg )</code> pair</p></div></div><div class="spec val" id="val-rev_collect"><a href="#val-rev_collect" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rev_collect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></div><div class="doc"><p>A &quot;collect&quot; function that convers <code class="code">'a t list -&gt; 'a list t</code>
Note: Tail-recursive, but reverses the list.</p></div></div><p>Parser combinators.</p><p>Each combinator takes the current message as the first argument and the
continuation function as the last argument.</p><p>A typical message parser would look like this.</p><pre><code class="code">        let parse_message msg = (
            repeating msg &quot;1&quot; parse_rg @@ fun msg group -&gt;
            check_duplicate_tags msg   @@ fun () -&gt;
            block     msg parse_blk    @@ fun msg block -&gt;
            req msg &quot;2&quot; parse_int      @@ fun msg x -&gt; 
            opt msg &quot;3&quot; parse_string   @@ fun msg y -&gt; 
            req msg &quot;4&quot; parse_int      @@ fun msg z -&gt; 
            ParseSuccess { block; group; x; y; z }, msg 
            ) |&gt; check_unknown_tags </code></pre><div class="spec val" id="val-opt"><a href="#val-opt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>opt : (string<span class="keyword"> * </span>string) list <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> (string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> option) <span class="keyword">&#8209;&gt;</span> ((string<span class="keyword"> * </span>string) list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> option <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list</code></div><div class="doc"><p>Optional field combinator, passes None into continuation if the tag is not present</p></div></div><div class="spec val" id="val-req"><a href="#val-req" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>req : (string<span class="keyword"> * </span>string) list <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> (string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> option) <span class="keyword">&#8209;&gt;</span> ((string<span class="keyword"> * </span>string) list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> list</code></div><div class="doc"><p>Required field combinator, returns RequiredTagMissing if the tag is not present</p></div></div><div class="spec val" id="val-block"><a href="#val-block" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>block : <a href="index.html#type-msg">msg</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-msg">msg</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-msg">msg</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a></code></div><div class="doc"><p>Block parser combinator parsers a record and passes it into the continuation</p></div></div><div class="spec val" id="val-repeating"><a href="#val-repeating" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>repeating : <a href="index.html#type-msg">msg</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-msg">msg</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-msg">msg</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a></code></div><div class="doc"><p>Repeating group parser combinator, starting from the tag that encodes
the length of the list, identifies the subgroups and passes each of them
into the block parser. Performs a number of consistency checks on the parsed
results.</p></div></div><div class="spec val" id="val-check_duplicate_tags"><a href="#val-check_duplicate_tags" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>check_duplicate_tags : <a href="index.html#type-msg">msg</a> <span class="keyword">&#8209;&gt;</span> (unit <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-msg">msg</a></code></div><div class="doc"><p>Checks for duplicate tags in messages -- should be called after all the repeating groups are porcessed</p></div></div><div class="spec val" id="val-check_unknown_tags"><a href="#val-check_unknown_tags" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>check_unknown_tags : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span>(string<span class="keyword"> * </span><span class="type-var">'b</span>) list) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>This finalizes the message -- if there are any unplrocessed tag=value pairs left -- we return an error</p></div></div><div class="spec val" id="val-get_top_and_last"><a href="#val-get_top_and_last" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_top_and_last : <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list<span class="keyword"> * </span><span class="type-var">'a</span> option</code></div><div class="doc"></div></div><div class="spec val" id="val-list_to_split"><a href="#val-list_to_split" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>list_to_split : string list <span class="keyword">&#8209;&gt;</span> char <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"></div></div><div class="spec val" id="val-split_to_list"><a href="#val-split_to_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>split_to_list : string <span class="keyword">&#8209;&gt;</span> char <span class="keyword">&#8209;&gt;</span> string list</code></div><div class="doc"></div></div></body></html>