module Internal : sig 
  
  module SessionManager : sig type t end

  type t

  type event =
    | OutFIXData of ( int * Full_app_messages.full_app_msg_data )
    | FIXMessage of Full_messages.full_top_level_msg
    | State      of Fix_engine_state.fix_engine_state

  type config = 
    { comp_id        : string
    ; host_id        : string option
    ; on_behalf_id   : string option
    ; target_id      : string
    ; timer          : float
    ; recv           : event -> unit Lwt.t 
    }

  val start : reset:bool -> session_dir:string -> config:config -> unit Lwt.t * t
  val send_fix : t -> Full_messages.full_top_level_msg -> unit Lwt.t
  val send_int : t -> Fix_engine_state.fix_engine_int_inc_msg -> unit Lwt.t
  val send_getstate : t -> unit Lwt.t

end = struct

  module SessionManager : sig 
    type t
    val save : t -> (int * int) -> unit Lwt.t
    val create : reset:bool -> dir:string -> t 
    val get : t -> (int * int)
  end = struct

    let (>>=) = Lwt.(>>=)

    type t =
      { dir : string
      ; seqin  : int 
      ; seqout : int 
      }

    let read_int file = try
        let chn = open_in file in
        let num = input_line chn in
        let () = close_in chn in
        num |> int_of_string |> Z.of_int
      with _exn -> 0
    
    let read_seqns dir =
      { dir
      ; seqin  = read_int Filename.(concat dir "seqin" ) 
      ; seqout = read_int Filename.(concat dir "seqout") 
      }

    let prepare_folder dir =
      if not(Caml_sys.file_exists dir) then 
        Caml_unix.(mkdir dir (Z.to_int 0o775)) 
      else ()   

    let write_int dir fname num =
      let filename = Filename.(concat dir fname) in 
      Lwt_io.(open_file ~mode:output filename) >>= fun fch ->
      Lwt_io.write fch (String.of_int num) >>= fun () ->
      Lwt_io.close fch

    let save state (seqin, seqout) =
      write_int state.dir "seqin"  seqin  >>= fun () ->
      write_int state.dir "seqout" seqout 

    let create ~reset ~dir =
      let () = prepare_folder dir in
      let state = read_seqns dir in
      let state = if reset then { state with seqin = 0; seqout = 0 } else state in
      state

    let get state = (state.seqin, state.seqout)

  end

  let (>>=) = Lwt.(>>=)

  type send_event =
    | SendInternal   of Fix_engine_state.fix_engine_int_inc_msg
    | SendFIXMessage of Full_messages.full_top_level_msg
    | GetState      

  type event =
    | OutFIXData of ( int * Full_app_messages.full_app_msg_data )
    | FIXMessage of Full_messages.full_top_level_msg
    | State      of Fix_engine_state.fix_engine_state

  type t = 
    { recv          : event -> unit Lwt.t
    ; send_box      : send_event Lwt_mvar.t
    ; timer         : float
    ; sess          : SessionManager.t    
    }

  let save_state_seqns sessn state =
    let seqin = state.Fix_engine_state.incoming_seq_num in
    let seqout = state.Fix_engine_state.outgoing_seq_num in
    SessionManager.save sessn (seqin, seqout)

  let extract_out_fix_data engine_state msg =
    let open Fix_engine_state in
    OutFIXData ( engine_state.incoming_seq_num , msg )

  (** Calls Fix_engine.one_step and pubs outgoing messages while busy *)  
  let rec while_busy_loop t engine_state  =
    let engine_state = Fix_engine.one_step engine_state in
    (* This assumes that after one_step we can get either ontgoing internal or outgoing FIX message *)
    begin match ( engine_state.outgoing_fix_msg , engine_state.outgoing_int_msg) with
      | Some msg, None -> t.recv ( FIXMessage msg )  
      | None, Some (OutIntMsg_ApplicationData msg)  
      | None, Some (OutIntMsg_ResendApplicationData msg) -> t.recv ( extract_out_fix_data engine_state msg ) 
      | None, Some _ 
      | None, None   -> Lwt.return_unit
      |  _ -> Lwt.fail_with "Critical internal error in fix_engine model" 
    end >>= fun () ->
    save_state_seqns t.sess engine_state >>= fun () ->
    let engine_state = { engine_state with outgoing_fix_msg = None ; outgoing_int_msg = None } in
    if Fix_engine_state.engine_state_busy engine_state then
      while_busy_loop t engine_state
    else Lwt.return engine_state
  
  let rec main_loop t engine_state =
    let open Fix_engine_state in 
    Lwt_mvar.take t.send_box >>= (function 
    | SendFIXMessage msg -> {engine_state with incoming_fix_msg = Some msg } |> while_busy_loop t
    | SendInternal   msg -> {engine_state with incoming_int_msg = Some msg } |> while_busy_loop t
    | GetState -> t.recv (State engine_state) >>= fun () -> Lwt.return engine_state
    ) >>= fun engine_state -> 
    main_loop t engine_state

  let do_timechange t =
    (** Timechange poster  *)
    let time = Time_defaults_current_time.get_current_utctimestamp () in
    let timechange = Fix_engine_state.IncIntMsg_TimeChange time in
    let timechange = SendInternal timechange in
    Lwt_mvar.put t.send_box timechange
    
  let rec heartbeat_thread t =
    (** Heartbeat thread  *)
    Lwt_unix.sleep t.timer >>= fun () -> 
    do_timechange t >>= fun () -> 
    heartbeat_thread t

  type config = 
    { comp_id        : string
    ; host_id        : string option
    ; on_behalf_id   : string option
    ; target_id      : string
    ; timer          : float
    ; recv           : event -> unit Lwt.t 
    }
  
  let make_engine_state (inseq, outseq) config =
    let open Fix_engine_state in
    { init_fix_engine_state with
      fe_comp_id = config.comp_id
    ; fe_sender_location_id = config.host_id
    ; fe_on_behalf_of_comp_id = config.on_behalf_id
    ; fe_target_comp_id = config.target_id
    ; fe_curr_time = Time_defaults_current_time.get_current_utctimestamp ()
    ; fe_max_num_logons_sent = 10
    ; fe_application_up = true
    ; incoming_seq_num = inseq
    ; outgoing_seq_num = outseq    
    }

  let start ~reset ~session_dir ~config  =
    let sess = SessionManager.create ~reset ~dir:session_dir in
    let (inseq, outsec) = SessionManager.get sess in
    let engine_state = make_engine_state (inseq, outsec) config in
    let state = 
      { recv = config.recv
      ; send_box = Lwt_mvar.create_empty ()
      ; timer = config.timer 
      ; sess
      } in
    let thread = Lwt.pick
      [ heartbeat_thread state
      ; main_loop state engine_state
      ] in
    ( thread , state )

  let send_fix state msg = 
    Lwt_mvar.put state.send_box (SendFIXMessage msg) >>= fun () ->
    do_timechange state

  let send_int state msg =
    Lwt_mvar.put state.send_box (SendInternal msg)

  let send_getstate state =
    Lwt_mvar.put state.send_box GetState


end

include Internal