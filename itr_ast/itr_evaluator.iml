[@@@program]

[@@@import "itr_ast.iml"]

[@@@import "itr_ast_pp.iml"]

[@@@import "../src-core-utils-pp/current_time.iml"]

open Itr_ast

let retrieve_current_vars (expr : expr) : (string * Z.t option) list list =
  let open Itr_ast in
  get_vars expr
  |> List.filter_map (function
         | Value (MessageValue { var = None; field_path }) ->
             Some field_path
         | _ ->
             None )


type msg_or_expr =
  | Msg of (Model_messages.model_msg_opt_def * string)
  | Record_item of record_item

type context =
  { local_vars : msg_or_expr String_map.t
  ; implicit_message : (Model_messages.model_msg_opt_def * string) option
  ; get_field :
         Model_messages.model_msg_opt_def
      -> (string * int option) list
      -> record_item
  }

let msg_or_expr_pp (ppf : Format.formatter) : msg_or_expr -> unit =
  let open Format in
  function
  | Msg _m ->
      fprintf ppf "<msg>"
  | Record_item e ->
      fprintf ppf "%a" Itr_ast_pp.record_item_pp e


let failing_msg expr =
  let open CCFormat in
  fprintf
    str_formatter
    "%s"
    (Yojson.Basic.to_string @@ Itr_ast_json_pp.record_item_to_json expr) ;
  flush_str_formatter ()


let rec replace_in_expr e e_check e_replace =
  if e = e_check
  then e_replace
  else
    match e with
    | Value (Funcall { func : string; args : record_item list }) ->
        Value
          (Funcall
             { func
             ; args =
                 List.map
                   (fun arg -> replace_in_record_item arg e_check e_replace)
                   args
             } )
    | Value _ ->
        e
    | Not expr ->
        Not (replace_in_expr expr e_check e_replace)
    | Or { lhs : expr; rhs : expr } ->
        Or
          { lhs = replace_in_expr lhs e_check e_replace
          ; rhs = replace_in_expr rhs e_check e_replace
          }
    | And { lhs : expr; rhs : expr } ->
        And
          { lhs = replace_in_expr lhs e_check e_replace
          ; rhs = replace_in_expr rhs e_check e_replace
          }
    | Eq { lhs : record_item; rhs : record_item } ->
        Eq
          { lhs = replace_in_record_item lhs e_check e_replace
          ; rhs = replace_in_record_item rhs e_check e_replace
          }
    | Cmp { lhs : expr; op : string; rhs : expr } ->
        Cmp
          { lhs = replace_in_expr lhs e_check e_replace
          ; op
          ; rhs = replace_in_expr rhs e_check e_replace
          }
    | Add { lhs : expr; op : char; rhs : expr } ->
        Add
          { lhs = replace_in_expr lhs e_check e_replace
          ; op
          ; rhs = replace_in_expr rhs e_check e_replace
          }
    | Mul { lhs : expr; op : char; rhs : expr } ->
        Mul
          { lhs = replace_in_expr lhs e_check e_replace
          ; op
          ; rhs = replace_in_expr rhs e_check e_replace
          }
    | In { el : expr; set : value } ->
        In { el = replace_in_expr el e_check e_replace; set }


and replace_in_record_item e e_check e_replace =
  match e with
  | Rec_value e ->
      Rec_value (replace_in_expr e e_check e_replace)
  | _ ->
      e


let e_true = Rec_value (Value (Literal (Bool true)))

let e_false = Rec_value (Value (Literal (Bool false)))

let e_none = Rec_value (Value (Literal LiteralNone))

let is_true = function
  | Rec_value (Value (Literal (Bool true))) ->
      true
  | _ ->
      false


let is_false = function
  | Rec_value (Value (Literal (Bool false))) ->
      true
  | _ ->
      false


let check_cmp lhs rhs op =
  match op with
  | "<" ->
    ( match (lhs, rhs) with
    | Value (Literal (Int l)), Value (Literal (Int r)) ->
        if l < r then e_true else e_false
    | Value (Literal (Float l)), Value (Literal (Float r)) ->
        if l <. r then e_true else e_false
    | ( Value (Literal (Datetime (UTCTimestamp l)))
      , Value (Literal (Datetime (UTCTimestamp r))) ) ->
        if Datetime.utctimestamp_LessThan_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCTimeOnly l)))
      , Value (Literal (Datetime (UTCTimeOnly r))) ) ->
        if Datetime.utctimeonly_LessThan_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCDateOnly l)))
      , Value (Literal (Datetime (UTCDateOnly r))) ) ->
        if Datetime.utcdateonly_LessThan l r then e_true else e_false
    | ( Value (Literal (Datetime (LocalMktDate l)))
      , Value (Literal (Datetime (LocalMktDate r))) ) ->
        if Datetime.localmktdate_LessThan l r then e_true else e_false
    | ( Value (Literal (Datetime (MonthYear l)))
      , Value (Literal (Datetime (MonthYear r))) ) ->
        if Datetime.monthyear_LessThan l r then e_true else e_false
    | _ ->
        Rec_value (Cmp { lhs; op; rhs }) )
  | ">" ->
    ( match (lhs, rhs) with
    | Value (Literal (Int l)), Value (Literal (Int r)) ->
        if l > r then e_true else e_false
    | Value (Literal (Float l)), Value (Literal (Float r)) ->
        if l >. r then e_true else e_false
    | ( Value (Literal (Datetime (UTCTimestamp l)))
      , Value (Literal (Datetime (UTCTimestamp r))) ) ->
        if Datetime.utctimestamp_GreaterThan_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCTimeOnly l)))
      , Value (Literal (Datetime (UTCTimeOnly r))) ) ->
        if Datetime.utctimeonly_GreaterThan_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCDateOnly l)))
      , Value (Literal (Datetime (UTCDateOnly r))) ) ->
        if Datetime.utcdateonly_GreaterThan l r then e_true else e_false
    | ( Value (Literal (Datetime (LocalMktDate l)))
      , Value (Literal (Datetime (LocalMktDate r))) ) ->
        if Datetime.localmktdate_GreaterThan l r then e_true else e_false
    | ( Value (Literal (Datetime (MonthYear l)))
      , Value (Literal (Datetime (MonthYear r))) ) ->
        if Datetime.monthyear_GreaterThan l r then e_true else e_false
    | _ ->
        Rec_value (Cmp { lhs; op; rhs }) )
  | "<=" ->
    ( match (lhs, rhs) with
    | Value (Literal (Int l)), Value (Literal (Int r)) ->
        if l <= r then e_true else e_false
    | Value (Literal (Float l)), Value (Literal (Float r)) ->
        if l <=. r then e_true else e_false
    | ( Value (Literal (Datetime (UTCTimestamp l)))
      , Value (Literal (Datetime (UTCTimestamp r))) ) ->
        if Datetime.utctimestamp_LessThanEqual_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCTimeOnly l)))
      , Value (Literal (Datetime (UTCTimeOnly r))) ) ->
        if Datetime.utctimeonly_LessThanEqual_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCDateOnly l)))
      , Value (Literal (Datetime (UTCDateOnly r))) ) ->
        if Datetime.utcdateonly_LessThanEqual l r then e_true else e_false
    | ( Value (Literal (Datetime (LocalMktDate l)))
      , Value (Literal (Datetime (LocalMktDate r))) ) ->
        if Datetime.localmktdate_LessThanEqual l r then e_true else e_false
    | ( Value (Literal (Datetime (MonthYear l)))
      , Value (Literal (Datetime (MonthYear r))) ) ->
        if Datetime.monthyear_LessThanEqual l r then e_true else e_false
    | _ ->
        Rec_value (Cmp { lhs; op; rhs }) )
  | ">=" ->
    ( match (lhs, rhs) with
    | Value (Literal (Int l)), Value (Literal (Int r)) ->
        if l >= r then e_true else e_false
    | Value (Literal (Float l)), Value (Literal (Float r)) ->
        if l >=. r then e_true else e_false
    | ( Value (Literal (Datetime (UTCTimestamp l)))
      , Value (Literal (Datetime (UTCTimestamp r))) ) ->
        if Datetime.utctimestamp_GreaterThanEqual_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCTimeOnly l)))
      , Value (Literal (Datetime (UTCTimeOnly r))) ) ->
        if Datetime.utctimeonly_GreaterThanEqual_micro_micro l r
        then e_true
        else e_false
    | ( Value (Literal (Datetime (UTCDateOnly l)))
      , Value (Literal (Datetime (UTCDateOnly r))) ) ->
        if Datetime.utcdateonly_GreaterThanEqual l r then e_true else e_false
    | ( Value (Literal (Datetime (LocalMktDate l)))
      , Value (Literal (Datetime (LocalMktDate r))) ) ->
        if Datetime.localmktdate_GreaterThanEqual l r then e_true else e_false
    | ( Value (Literal (Datetime (MonthYear l)))
      , Value (Literal (Datetime (MonthYear r))) ) ->
        if Datetime.monthyear_GreaterThanEqual l r then e_true else e_false
    | _ ->
        Rec_value (Cmp { lhs; op; rhs }) )
  | _ ->
      Rec_value (Cmp { lhs; op; rhs })


let rec is_ground_expr : expr -> bool = function
  | Value (Variable (Var _v)) ->
      false
  | Value (MessageValue _mv) ->
      false
  | Value _ ->
      true
  | Not e1 ->
      is_ground_expr e1
  | Or { lhs; rhs }
  | And { lhs; rhs }
  | Cmp { lhs; rhs; _ }
  | Add { lhs; rhs; _ }
  | Mul { lhs; rhs; _ } ->
      is_ground_expr lhs && is_ground_expr rhs
  | Eq { lhs = Rec_value lhs; rhs = Rec_value rhs } ->
      is_ground_expr lhs && is_ground_expr rhs
  | In { el; _ } ->
      is_ground_expr el
  | _ ->
      true


let rec is_ground (e : record_item) : bool =
  match e with
  | Rec_value r ->
      is_ground_expr r
  | Rec_record { elements; _ } ->
      String_map.for_all (fun _ x -> is_ground x) elements
  (* TODO checking of ground for repeating group structures *)
  | _ ->
      false


let rec evaluate_record_item (context : context option) (e : record_item) :
    record_item =
  match e with
  | Rec_value r ->
      evaluate_expr context r
  | Rec_record { name; elements } ->
      Rec_record
        { name
        ; elements = String_map.map (evaluate_record_item context) elements
        }
  (* TODO simplification of repeating group structures *)
  | _ ->
      e


and evaluate_expr (context : context option) (e : expr) : record_item =
  let evaluate_expr = evaluate_expr context in
  let evaluate_record_item = evaluate_record_item context in
  match e with
  | Not expr ->
    ( match evaluate_expr expr with
    | Rec_value (Value (Literal (Bool true))) ->
        Rec_value (Value (Literal (Bool false)))
    | Rec_value (Value (Literal (Bool false))) ->
        Rec_value (Value (Literal (Bool true)))
    | Rec_value e ->
        Rec_value (Not e)
    | _ ->
        Rec_value e )
  | Or { lhs : expr; rhs : expr } ->
      let lhs = evaluate_expr lhs in
      let rhs = evaluate_expr rhs in
      if is_true lhs || is_true rhs
      then e_true
      else if is_false lhs && is_false rhs
      then e_false
      else (
        match (lhs, rhs) with
        | Rec_value lhs, Rec_value rhs ->
            Rec_value (Or { lhs; rhs })
        | _ ->
            Rec_value e )
  | And { lhs : expr; rhs : expr } ->
      let lhs = evaluate_expr lhs in
      let rhs = evaluate_expr rhs in
      if is_true lhs && is_true rhs
      then e_true
      else if is_false lhs || is_false rhs
      then e_false
      else (
        match (lhs, rhs) with
        | Rec_value lhs, Rec_value rhs ->
            Rec_value (And { lhs; rhs })
        | _ ->
            Rec_value e )
  | Eq { lhs : record_item; rhs : record_item } ->
      let lhs = evaluate_record_item lhs in
      let rhs = evaluate_record_item rhs in
      if lhs = rhs
      then e_true
      else if (* only evaluate equality to false if the terms have no variables *)
              is_ground lhs && is_ground rhs
      then e_false
      else Rec_value (Eq { lhs; rhs })
  | Cmp { lhs : expr; op : string; rhs : expr } ->
      let lhs = evaluate_expr lhs in
      let rhs = evaluate_expr rhs in
      ( match (lhs, rhs) with
      | Rec_value lhs, Rec_value rhs ->
          check_cmp lhs rhs op
      | _ ->
          Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "String.length" && List.length args = 1 ->
    ( match args with
    | [ a ] ->
      ( match evaluate_record_item a with
      | Rec_value (Value (Literal (String s))) ->
          Rec_value (Value (Literal (Int (String.length s))))
      | _ ->
          Rec_value e )
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when (func = "String.length" || func = "LString.length")
         && List.length args = 1 ->
    ( match args with
    | [ a ] ->
      ( match evaluate_record_item a with
      | Rec_value (Value (Literal (String s))) ->
          Rec_value (Value (Literal (Int (String.length s))))
      | _ ->
          Rec_value e )
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "IsSet" && List.length args = 1 ->
    ( match args with
    | [ a ] ->
        let ri = evaluate_record_item a in
        if ri = e_none
        then Rec_value (Value (Literal (Bool false)))
        else if is_ground ri && ri <> e_none
        then Rec_value (Value (Literal (Bool true)))
        else Rec_value e
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "defaultIfNotSet" && List.length args = 2 ->
    ( match args with
    | [ d; a ] ->
        let a = evaluate_record_item a in
        ( match a with
        | Rec_value (Value (Literal LiteralNone)) ->
            evaluate_record_item d
        | _ ->
            a )
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "Set.subset" && List.length args = 2 ->
    ( match args with
    | [ l; r ] ->
        let l = evaluate_record_item l in
        let r = evaluate_record_item r in
        ( match (l, r) with
        | ( Rec_value (Value (Literal (Coll l)))
          , Rec_value (Value (Literal (Coll r))) ) ->
            if CCList.subset ~eq:(fun a b -> a = b) l r then e_true else e_false
        | _l, _r ->
            (* print_endline @@ (let j = Itr_ast_json_pp.expr_to_json l in Yojson.Basic.to_string j);
               print_endline @@ (let j = Itr_ast_json_pp.expr_to_json r in Yojson.Basic.to_string j); *)
            Rec_value e )
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "FormatDate" ->
    ( match args with
    | [ date; Rec_value (Value (Literal (String "yyyyMMdd"))) ] ->
      ( match evaluate_record_item date with
      | Rec_value (Value (Literal (Datetime (UTCTimestamp t)))) ->
          Rec_value
            (Value
               (Literal
                  (Datetime
                     (UTCDateOnly
                        (Datetime.convert_utctimestamp_micro_utcdateonly t) ) )
               ) )
      | _ ->
          Rec_value e )
    | [ date; Rec_value (Value (Literal (String "yyyyMMdd-HH:mm:ss.SSS"))) ] ->
        evaluate_record_item date
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "date" && args = [] ->
      Rec_value
        (Value
           (Literal
              (Datetime
                 (UTCTimestamp (Current_time.get_current_utctimestamp_micro ()))
              ) ) )
  | Value (Funcall { func : string; args : record_item list })
    when func = "timestamp_to_dateonly" && List.length args = 1 ->
    ( match args with
    | [ a ] ->
      ( match evaluate_record_item a with
      | Rec_value (Value (Literal (Datetime (UTCTimestamp t)))) ->
          Rec_value
            (Value
               (Literal
                  (Datetime
                     (UTCDateOnly
                        (Datetime.convert_utctimestamp_micro_utcdateonly t) ) )
               ) )
      | _ ->
          Rec_value e )
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "timestamp_to_localmktdate" && List.length args = 1 ->
    ( match args with
    | [ a ] ->
      ( match evaluate_record_item a with
      | Rec_value (Value (Literal (Datetime (UTCTimestamp t)))) ->
          Rec_value
            (Value
               (Literal
                  (Datetime
                     (LocalMktDate
                        (Datetime.convert_utctimestamp_micro_localmktdate t) )
                  ) ) )
      | _ ->
          Rec_value e )
    | _ ->
        Rec_value e )
  | Value (Funcall { func : string; args : record_item list })
    when func = "randInt" && List.length args = 2 ->
    ( match args with
    | [ l; u ] ->
      ( match (evaluate_record_item l, evaluate_record_item u) with
      | Rec_value (Value (Literal (Int l))), Rec_value (Value (Literal (Int u)))
        ->
          let r = Z.of_int (Random.int (Z.to_int (u - l))) + l in
          Rec_value (Value (Literal (String (Z.to_string r))))
      | _ ->
          Rec_value e )
    | _ ->
        Rec_value e )
  | Value (Funcall _) ->
      Rec_value e
  | Value (Variable (Var v)) ->
    ( match context with
    | None ->
        Rec_value e
    | Some context ->
      ( match String_map.get v context.local_vars with
      | Some (Record_item ri) ->
          evaluate_record_item ri
      | _ ->
          Rec_value e ) )
  | Value (Literal (Coll l)) ->
      Rec_value (Value (Literal (Coll (List.map evaluate_record_item l))))
  | Value (Literal (LiteralSome s)) ->
      evaluate_record_item s
  | Value (MessageValue { var; field_path }) ->
    ( match context with
    | None ->
        Rec_value e
    | Some context ->
      ( match (var, context.implicit_message) with
      | Some x, _ ->
        ( match String_map.get (Var.name x) context.local_vars with
        | Some (Msg (msg, _tag)) ->
            evaluate_record_item (context.get_field msg field_path)
        | Some (Record_item ri) ->
            evaluate_record_item ri
        | _ ->
            Rec_value e )
      | None, Some (msg, _tag) ->
          evaluate_record_item (context.get_field msg field_path)
      | None, None ->
          Rec_value e ) )
  | Add { lhs : expr; op : char; rhs : expr } ->
      let lhs, rhs = (evaluate_expr lhs, evaluate_expr rhs) in
      ( match (lhs, rhs) with
      | Rec_value lhs, Rec_value rhs ->
        ( match (lhs, op, rhs) with
        | Value (Literal (Int a)), '+', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Int (a + b))))
        | Value (Literal (Float a)), '+', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (a +. b))))
        | Value (Literal (Float a)), '+', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Float (a +. Q.of_bigint b))))
        | Value (Literal (Int a)), '+', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (Q.of_bigint a +. b))))
        | Value (Literal (Int a)), '-', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Int (a - b))))
        | Value (Literal (Float a)), '-', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (a -. b))))
        | Value (Literal (Float a)), '-', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Float (a -. Q.of_bigint b))))
        | Value (Literal (Int a)), '-', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (Q.of_bigint a -. b))))
        | Value (Literal (String a)), '+', Value (Literal (String b)) ->
            Rec_value (Value (Literal (String (a ^ b))))
        | Value (Literal (String a)), '+', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (String (a ^ Z.to_string b))))
        | Value (Literal (Int a)), '+', Value (Literal (String b)) ->
            Rec_value (Value (Literal (String (Z.to_string a ^ b))))
        | Value (Literal (String a)), '+', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (String (a ^ Q.to_string b))))
        | Value (Literal (Float a)), '+', Value (Literal (String b)) ->
            Rec_value (Value (Literal (String (Q.to_string a ^ b))))
        | _, '+', _ | _, '-', _ ->
            Rec_value e
        | _, _, _ ->
            failwith "Unknown Add operator" )
      | _ ->
          Rec_value e )
  | Mul { lhs : expr; op : char; rhs : expr } ->
      let lhs, rhs = (evaluate_expr lhs, evaluate_expr rhs) in
      ( match (lhs, rhs) with
      | Rec_value lhs, Rec_value rhs ->
        ( match (lhs, op, rhs) with
        | Value (Literal (Int a)), '*', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Int (a * b))))
        | Value (Literal (Float a)), '*', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (a *. b))))
        | Value (Literal (Float a)), '*', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Float (a *. Q.of_bigint b))))
        | Value (Literal (Int a)), '*', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (Q.of_bigint a *. b))))
        | Value (Literal (Int a)), '/', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Float (Q.of_bigint a /. Q.of_bigint b))))
        | Value (Literal (Float a)), '/', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (a /. b))))
        | Value (Literal (Float a)), '/', Value (Literal (Int b)) ->
            Rec_value (Value (Literal (Float (a /. Q.of_bigint b))))
        | Value (Literal (Int a)), '/', Value (Literal (Float b)) ->
            Rec_value (Value (Literal (Float (Q.of_bigint a /. b))))
        | _, '+', _ | _, '-', _ ->
            Rec_value e
        | _, _, _ ->
            failwith "Unknown Mul operator" )
      | _ ->
          Rec_value e )
  | In { el : expr; set : value } ->
    ( match evaluate_expr (Value set) with
    | Rec_value (Value (Literal (Coll es))) ->
        Rec_value
          (Value
             (Literal
                (Bool
                   (List.mem
                      (evaluate_expr el)
                      (List.map evaluate_record_item es) ) ) ) )
    | _ ->
        Rec_value e )
  | _ ->
      Rec_value e


let nullable_expr
    (expr : expr) (message_field_optional_map : bool String_map.t option) :
    Field_path_set.t =
  let open Itr_ast in
  let this_msg_vars =
    match message_field_optional_map with
    | None ->
        Field_path_set.empty
    | Some message_field_optional_map ->
        retrieve_current_vars expr
        |> List.filter (fun l ->
               let nm = String.concat "." (List.map fst l) in
               match String_map.get nm message_field_optional_map with
               | None ->
                   false
               | Some is_optional ->
                   is_optional )
        |> Field_path_set.of_list
  in
  let nullable_var_names =
    Field_path_set.fold
      (fun el acc ->
        let expr =
          replace_in_expr
            expr
            (Value (MessageValue { var = None; field_path = el }))
            (Value (Literal LiteralNone))
        in
        let record_item = evaluate_expr None expr in
        if is_true @@ evaluate_record_item None record_item
        then Field_path_set.add el acc
        else acc )
      this_msg_vars
      Field_path_set.empty
  in
  nullable_var_names


[@@@logic]
