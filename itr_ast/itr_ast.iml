(* Imandra Inc. copyright 2021 *)
[@@@program]
[@@@import "../src-core/datetime.iml"]
module Map_extra (M : CCMap.S) = struct
  include M

  let merge_keep_left m1 m2 =
    merge_safe m1 m2 ~f:(fun _ -> function
      | `Left a -> Some a | `Right b -> Some b | `Both (a, _) -> Some a)


  let merge_all_keep_left = function
    | [] ->
        empty
    | m :: ms ->
        CCList.fold_left merge_keep_left m ms
end

module String_map = Map_extra (CCMap.Make (CCString))

let pp_string fmt s = CCFormat.(fprintf fmt "%S" s)

module Var = struct
  type t = Var of string

  let mk v = Var v

  let name (Var v) = v

  let pp fmt =
    let open CCFormat in
    function Var v -> fprintf fmt "$%s" v
end

module Message_value = struct
  type t =
    { var : Var.t option
    ; field_path : (string * int option) list
    }

  let mk ~var field_path = { var; field_path }

  let to_json t : Yojson.Basic.t =
    let pre : Yojson.Basic.t =
      match t.var with None -> `Null | Some v -> `String (Var.name v)
    in
    let post : string * Yojson.Basic.t =
      ( "field_path"
      , `List
          (List.map
             (fun (x, o) ->
               `Assoc
                 [ ("name", `String x)
                 ; ( "index"
                   , match o with None -> `Null | Some x -> `Int (Z.to_int x) )
                 ])
             t.field_path) )
    in
    let ent = [ ("var_name", pre); post ] in
    `Assoc ent


  let pp fmt t =
    let open CCFormat in
    let index_pp fmt = function
      | s, None ->
          fprintf fmt "%s" s
      | s, Some index ->
          fprintf fmt "%s[%i]" s (Z.to_int index)
    in
    let pp_var_opt fmt = function
      | None ->
          ()
      | Some v ->
          fprintf fmt "%a." Var.pp v
    in
    fprintf
      fmt
      "%a%a"
      pp_var_opt
      t.var
      (list ~sep:(return ".") index_pp)
      t.field_path
end

module Connection_ref = struct
  type t =
    | String of string
    | Var of Var.t

  let string s = String s

  let var v = Var (Var.mk v)

  let to_json t =
    match t with
    | String s ->
        `Assoc [ ("string", `String s) ]
    | Var v ->
        `Assoc [ ("var", `String (Var.name v)) ]


  let pp fmt t =
    let open CCFormat in
    let pp_inner fmt = function
      | String s ->
          pp_string fmt s
      | Var v ->
          Var.pp fmt v
    in
    fprintf fmt "[%a]" pp_inner t
end

type datetime =
  | UTCTimestamp of Datetime.fix_utctimestamp_micro
  | UTCTimeOnly of Datetime.fix_utctimeonly_micro
  | UTCDateOnly of Datetime.fix_utcdateonly
  | LocalMktDate of Datetime.fix_localmktdate
  | MonthYear of Datetime.fix_monthyear

type literal =
  | Bool of bool
  | Int of int
  | String of string
  | UnquotedString of string
  | Float of real
  | Coll of expr list
  | MapColl of (expr*expr) list
  | LiteralNone
  | LiteralSome of expr
  | Datetime of datetime

and value =
  | Literal of literal
  | Variable of Var.t
  | MessageValue of Message_value.t
  | ConnectionRef of Connection_ref.t
  | TODOHex of string
  | Now
  | Counter
  | ObjectProperty of
      { obj : expr
      ; index : int option
      ; prop : string
      }
  | Funcall of
      { func : string
      ; args : expr list
      }
  | Record_item of record_item

and expr =
  | Value of value
  | Not of expr
  | In of
      { el : expr
      ; set : expr
      }
  | Arrow of
      { condition : expr
      ; assertion : expr
      }
  | Or of
      { lhs : expr
      ; rhs : expr
      }
  | And of
      { lhs : expr
      ; rhs : expr
      }
  | Eq of
      { lhs : expr
      ; rhs : expr
      }
  | Like of
      { lhs : expr
      ; rhs : expr
      }
  | Cmp of
      { lhs : expr
      ; op : string
      ; rhs : expr
      }
  | Add of
      { lhs : expr
      ; op : char
      ; rhs : expr
      }
  | Mul of
      { lhs : expr
      ; op : char
      ; rhs : expr
      }

and record = {name:string;elements:record_item String_map.t}

and record_item =
  | Rec_value of expr
  | Rec_record of record
  | Rec_repeating_group of
      {name: string
      ; message_template: string option
      ; num_in_group_field : string
      ; elements : record list
      }


let rec expr_eq e1 e2 =
  match (e1, e2) with
  | Value v1, Value v2 ->
      value_eq v1 v2
  | Not e1, Not e2 ->
      expr_eq e1 e2
  | ( Arrow { condition = c1; assertion = a1 }
    , Arrow { condition = c2; assertion = a2 } ) ->
      expr_eq c1 c2 && expr_eq a1 a2
  | Or { lhs = lhs1; rhs = rhs1 }, Or { lhs = lhs2; rhs = rhs2 }
  | And { lhs = lhs1; rhs = rhs1 }, And { lhs = lhs2; rhs = rhs2 }
  | Eq { lhs = lhs1; rhs = rhs1 }, Eq { lhs = lhs2; rhs = rhs2 }
  | Like { lhs = lhs1; rhs = rhs1 }, Like { lhs = lhs2; rhs = rhs2 } ->
      expr_eq lhs1 lhs2 && expr_eq rhs1 rhs2
  | ( Cmp { lhs = lhs1; rhs = rhs1; op = op1 }
    , Cmp { lhs = lhs2; rhs = rhs2; op = op2 } ) ->
      op1 = op2 && expr_eq lhs1 lhs2 && expr_eq rhs1 rhs2
  | ( Add { lhs = lhs1; rhs = rhs1; op = op1 }
    , Add { lhs = lhs2; rhs = rhs2; op = op2 } )
  | ( Mul { lhs = lhs1; rhs = rhs1; op = op1 }
    , Mul { lhs = lhs2; rhs = rhs2; op = op2 } ) ->
      op1 = op2 && expr_eq lhs1 lhs2 && expr_eq rhs1 rhs2
  | _ ->
      false


and value_eq v1 v2 =
  match (v1, v2) with
  | Record_item i1, Record_item i2 ->
      record_item_eq i1 i2
  | ( Funcall { func = func1; args = args1 }
    , Funcall { func = func2; args = args2 } ) ->
      func1 = func2 && CCList.equal expr_eq args1 args2
  | _ ->
      v1 = v2


and record_item_eq i1 i2 =
  match (i1, i2) with
  | Rec_value e1, Rec_value e2 ->
      expr_eq e1 e2
  | Rec_record r1, Rec_record r2 ->
      record_eq r1 r2
  | ( Rec_repeating_group { name = nm1; num_in_group_field = n1; elements = elements1;_ }
    , Rec_repeating_group { name = nm2; num_in_group_field = n2; elements = elements2;_ } ) ->
      nm1 = nm2 && n1 = n2 && CCList.equal record_eq elements1 elements2
  | _ ->
      false


and record_eq r1 r2 = r1.name = r2.name && String_map.equal record_item_eq r1.elements r2.elements

let map_value ~map_expr ~map_record_item = function
  | ObjectProperty { obj; index; prop } ->
      ObjectProperty { obj = map_expr obj; index; prop }
  | Funcall { func; args } ->
      Funcall { func; args = CCList.map map_expr args }
  | Record_item record_item ->
      Record_item (map_record_item record_item)
  | v ->
      v


let map_expr ~map_expr:f ~map_value = function
  | Value v ->
      Value (map_value v)
  | Not e ->
      Not (f e)
  | Arrow { condition; assertion } ->
      Arrow { condition = f condition; assertion = f assertion }
  | Or { lhs; rhs } ->
      Or { lhs = f lhs; rhs = f rhs }
  | And { lhs; rhs } ->
      And { lhs = f lhs; rhs = f rhs }
  | Eq { lhs; rhs } ->
      Eq { lhs = f lhs; rhs = f rhs }
  | Like { lhs; rhs } ->
      Like { lhs = f lhs; rhs = f rhs }
  | Cmp { lhs; op; rhs } ->
      Cmp { lhs = f lhs; op; rhs = f rhs }
  | Add { lhs; op; rhs } ->
      Add { lhs = f lhs; op; rhs = f rhs }
  | Mul { lhs; op; rhs } ->
      Mul { lhs = f lhs; op; rhs = f rhs }
  | In { el; set } ->
      In { el = f el; set = f set }


let map_record_item ~map_expr ~map_record = function
  | Rec_value expr ->
      Rec_value (map_expr expr)
  | Rec_record record ->
      Rec_record (map_record record)
  | Rec_repeating_group { num_in_group_field; elements; name; message_template } ->
      Rec_repeating_group
        { num_in_group_field; name; message_template; elements = CCList.map map_record elements }


let map_record ~map_record_item r = {name = r.name; elements = String_map.map map_record_item r.elements}

let map f =
  let rec mri item =
    map_record_item
      ~map_expr:f
      ~map_record:(map_record ~map_record_item:mri)
      item
  in
  map_expr ~map_expr:f ~map_value:(map_value ~map_expr:f ~map_record_item:mri)


let rec walk f e =
  let e = f e in
  map (walk f) e


exception Iterated

let iterated () = raise Iterated

let iter f e =
  try
    ignore
      (walk
         (fun e ->
           f e ;
           e)
         e)
  with
  | Iterated ->
      ()


let exists f e =
  let found = ref false in
  iter
    (fun e ->
      if f e
      then (
        found := true ;
        iterated () ))
    e ;
  !found


let rec fold f init e =
  let init = f init e in
  match e with
  | Value _ ->
      init
  | Not e1 ->
      fold f init e1
  | Arrow { condition; assertion } ->
      let init = fold f init condition in
      fold f init assertion
  | Or { lhs; rhs }
  | And { lhs; rhs }
  | Eq { lhs; rhs }
  | Like { lhs; rhs }
  | Cmp { lhs; rhs; _ }
  | Add { lhs; rhs; _ }
  | Mul { lhs; rhs; _ } ->
      let init = fold f init lhs in
      let init = fold f init rhs in
      init
  | In { el; set } ->
      let init = fold f init el in
      let init = fold f init set in
      init


let is_funcall = function Value (Funcall _) -> true | _ -> false

let bool b = Value (Literal (Bool b))

let string s = Value (Literal (String s))

let unquoted_string s = Value (Literal (UnquotedString s))

let int i = Value (Literal (Int i))

let var v = Value (Variable (Var.mk v))

let connection_ref c = Value (ConnectionRef c)

let object_property obj ?index prop =
  Value (ObjectProperty { obj; index; prop })


let message_value ?var field_path =
  Value
    (MessageValue
       { var; field_path = field_path |> CCList.map (fun f -> (f, None)) })


let funcall func args = Value (Funcall { func; args })

let and_ lhs rhs = And { lhs; rhs }

let or_ lhs rhs = Or { lhs; rhs }

let gt lhs rhs = Cmp { lhs; op = ">"; rhs }

let add lhs rhs = Add { lhs; rhs; op = '+' }

let sub lhs rhs = Add { lhs; rhs; op = '-' }

let is_set e = funcall "IsSet" [ e ]

let eq lhs rhs = Eq { lhs; rhs }

let eq_opt lhs rhs =
  or_ (and_ (Not (is_set lhs)) (Not (is_set rhs))) (eq lhs rhs)


let add_eval lhs rhs =
  match (lhs, rhs) with
  | Value (Literal (String lhs)), Value (Literal (String rhs)) ->
      Value (Literal (String (lhs ^ rhs)))
  | _ ->
      add lhs rhs


let concat ?sep = function
  | [] ->
      string ""
  | e :: es ->
      let add e1 e2 =
        match sep with
        | None ->
            add_eval e1 e2
        | Some sep ->
            add_eval e1 (add_eval sep e2)
      in
      CCList.fold_left add e es


let simplify e =
  let rec simplify_rec e acc_string acc_list =
    match e with
    | [] ->
        acc_list
    | Value (Literal (String s)) :: t ->
        simplify_rec t (acc_string ^ s) acc_list
    | h :: t ->
        simplify_rec
          t
          ""
          ( acc_list
          @ (match acc_string with "" -> [] | _ -> [ string acc_string ])
          @ [ h ] )
  in
  concat (simplify_rec e "" [])


let all = function
  | [] ->
      bool true
  | e :: es ->
      CCList.fold_left
        (fun e c ->
          match c with Value (Literal (Bool true)) -> e | _ -> and_ e c)
        e
        es


let convert_timestamp_localmktdate date =
  funcall "timestamp_to_localmktdate" [ date ]


let convert_timestamp_dateonly date = funcall "timestamp_to_dateonly" [ date ]

let empty_record : record = {name = "";elements = String_map.empty}

let rec map_value_in_record (path : string list) f (record : record) =
  match path with
  | [] ->
      record
  | [ field ] ->
      {name = record.name;elements = record.elements |> String_map.update field f}
  | field :: path ->
      {name= record.name;elements = record.elements
      |> String_map.update field (fun entry ->
             let record =
               match entry with
               | Some (Rec_record record) ->
                   record
               | _ ->
                   empty_record
             in
             Some (Rec_record (map_value_in_record path f record)))}


(** Given a record, return a list of paths to expressions that reference all the
    fields in the record.

    E.g. the record

        Parties [
          { PartyID = "123" }
          { PartyID = "456" }
        ]

    Returns

       [ (["Parties[0]"; "PartyID"], "123")
       ; (["Parties[1]"; "PartyID"], "456")
       ]
*)
let rec flatten_record ?qualify_records (r : record) : (string list * expr) list
    =
  r.elements
  |> String_map.to_list
  |> CCList.flat_map (fun (field, (item : record_item)) ->
         flatten_record_item ?qualify_records field item)


and flatten_record_item ?(qualify_records = true) field (i : record_item) =
  match i with
  | Rec_value expr ->
      [ ([ field ], expr) ]
  | Rec_record record ->
      flatten_record ~qualify_records record
      |> CCList.map (fun (path, expr) ->
             if qualify_records then (field :: path, expr) else (path, expr))
  | Rec_repeating_group { num_in_group_field; elements;_ } ->
      elements
      |> CCList.mapi (fun i record ->
             flatten_record ~qualify_records record
             |> CCList.map (fun (path, expr) ->
                    ( field
                      :: Printf.sprintf "%s[%i]" num_in_group_field i
                      :: path
                    , expr )))
      |> CCList.concat


module Template = struct
  type t =
    | Name of (string * string)
    | Var of (Var.t * string)

  let name s tag = Name (s, tag)

  let var v tag = Var (Var.mk v, tag)

  let to_json (t : t) : Yojson.Basic.t =
    match t with
    | Name (_, s) ->
        `Assoc [ ("name", `String s) ]
    | Var (_, s) ->
        `Assoc [ ("var", `String s) ]


  let pp fmt t =
    let open CCFormat in
    let pp_inner fmt = function
      | Name (s, _) ->
          pp_string fmt s
      | Var (v, _) ->
          Var.pp fmt v
    in
    fprintf fmt "%a" pp_inner t
end

type typed_term =
  { name : string
  ; type_ : string option
  }

type expecting =
  { modifier : [ `Only | `Only_supported ] option
  ; exprs : expr list
  }

type field =
 { name: string
 ; value : record_item
 }

type instruction =
  | Break
  | Print of expr
  | Run of expr
  | Sleep of expr
  | Assert of expr
  | Fail of expr option
  | Return of expr option
  | Goto of string
  | Label of string
  | Connect of
      { connection : Connection_ref.t
      ; timeout : expr option
      ; block : bool
      }
  | Disconnect of Connection_ref.t
  | Action of {name:string;fields:field list}
  | Message of {name:string;fields:field list}
  | Set of
      { prop : string
      ; value : expr
      }
  | Unset of value
  | Call of
      { variable : Var.t option
      ; call : value
      }
  | Send of
      { variable : Var.t option
      ; template : Template.t
      ; connection : Connection_ref.t
      ; using : string option
      ; withs : record option
      }
  | ExpectingOf of
      { variable : Var.t
      ; expecting : expecting
      }
  | Template of
      { variable : Var.t option
      ; template : Template.t
      ; connection : Connection_ref.t
      ; using : string option
      }
  | Cleanup of instruction list
  | OnExpired of instruction list
  | Repeat of
      { ntimes : expr option
      ; instructions : instruction list
      }
  | ForEach of
      { dataset : expr
      ; instructions : instruction list
      }
  | Receive of
      { variable : Var.t option
      ; connection : Connection_ref.t
      ; timeout : expr option
      ; where : expr
      ; expecting : expecting option
      }
  | IfThenElse of
      { cond : expr
      ; then_ : instruction list
      ; else_ : instruction list
      }
  | FunctionDef of
      { name : string
      ; args : typed_term list
      ; body : instruction list
      }
  | Comment of string

module Instructions_set = CCSet.Make (struct
  type t = instruction list

  let compare = Caml.compare
end)

module Value = struct
  type t = value

  let rec exists f v =
    f v
    ||
    match v with
    | Literal _
    | Variable _
    | MessageValue _
    | ConnectionRef _
    | TODOHex _
    | Now
    | Counter ->
        false
    | ObjectProperty { obj = e; index = _; prop = _ } ->
        exists_expr f e
    | Funcall { func = _; args = es } ->
        CCList.exists (exists_expr f) es
    | Record_item record_item ->
        exists_record_item f record_item


  and exists_expr f = function
    | Value v ->
        exists f v
    | Not e ->
        exists_expr f e
    | Arrow { condition; assertion } ->
        exists_expr f condition || exists_expr f assertion
    | Or { lhs; rhs }
    | And { lhs; rhs }
    | Eq { lhs; rhs }
    | Like { lhs; rhs }
    | Cmp { lhs; rhs; op = _ }
    | Add { lhs; rhs; op = _ }
    | Mul { lhs; rhs; op = _ } ->
        exists_expr f lhs || exists_expr f rhs
    | In { el; set } ->
        exists_expr f el || exists_expr f set


  and exists_record_item f = function
    | Rec_value e ->
        exists_expr f e
    | Rec_record record ->
        exists_record f record
    | Rec_repeating_group { num_in_group_field = _; elements;_ } ->
        CCList.exists (exists_record f) elements


  and exists_record f r =
    String_map.exists (fun _ record_item -> exists_record_item f record_item) r.elements


  let rec exists_instruction f = function
    | Break | Goto _ | Label _ | Disconnect _ | Comment _ | Template _ ->
        false
    | Call { variable = _; call = v } | Unset v ->
        exists f v
    | ExpectingOf { variable = _; expecting = { exprs = es; modifier = _ } } ->
        CCList.exists (exists_expr f) es
    | Print e | Run e | Sleep e | Assert e | Set { prop = _; value = e } ->
        exists_expr f e
    | Fail e | Return e | Connect { connection = _; timeout = e; block = _ } ->
        e |> CCOpt.exists (exists_expr f)
    | Action {fields;_} ->
        CCList.exists (exists_record_item f) (List.map (fun x -> x.value) fields)
    | Message {fields;_} ->
        CCList.exists (exists_record_item f) (List.map (fun x -> x.value) fields)
    | Send
        { variable = _
        ; template = _
        ; connection = _
        ; using = _
        ; withs = record
        } ->
        CCOpt.exists (exists_record f) record
    | Cleanup is
    | OnExpired is
    | Repeat { ntimes = _; instructions = is }
    | FunctionDef { name = _; args = _; body = is } ->
        CCList.exists (exists_instruction f) is
    | ForEach { dataset = e; instructions = is } ->
        exists_expr f e || CCList.exists (exists_instruction f) is
    | Receive { variable = _; connection = _; timeout; where; expecting } ->
        CCOpt.exists (exists_expr f) timeout
        || exists_expr f where
        || CCOpt.exists
             (fun (e : expecting) -> CCList.exists (exists_expr f) e.exprs)
             expecting
    | IfThenElse { cond; then_; else_ } ->
        exists_expr f cond
        || CCList.exists (exists_instruction f) then_
        || CCList.exists (exists_instruction f) else_
end

let append ~to_ e = Set { prop = to_; value = add (var to_) e }

(** Combine:

      set x = $x + "1"
      set x = $x + "2"

    Into:

      set x = $x + "1" + "2"
*)
let rec combine_appends ~var = function
  | Set { prop = x1; value }
    :: Set
         { prop = x2
         ; value = Add { lhs = Value (Variable (Var x3)); rhs; op = '+' }
         }
       :: is
    when x1 = var && x2 = var && x3 = var ->
      let i =
        match value with
        | Add { lhs = Value (Variable (Var x4)); rhs = value; op = '+' }
          when x4 = var ->
            append ~to_:var (add_eval value rhs)
        | _ ->
            Set { prop = var; value = add value rhs }
      in
      combine_appends ~var (i :: is)
  | i :: is ->
      i :: combine_appends ~var is
  | [] ->
      []


let is_local_message_value = function
  | Value (MessageValue { var = None; _ }) ->
      true
  | _ ->
      false


let rec eval_pp_value ~var (value : value) : instruction list =
  let append e = append ~to_:var e in
  match value with
  | MessageValue ({ var = None; _ } as mv) ->
      [ append (string (CCFormat.sprintf "%a" Message_value.pp mv)) ]
  | Funcall _ ->
      (* todo for printing *) []
  | Literal _
  | Variable _
  | MessageValue _
  | ConnectionRef _
  | TODOHex _
  | Now
  | Counter
  (* TODO *)
  | ObjectProperty _
  | Record_item _ ->
      [ append (Value value) ]


and eval_pp_expr ~var (e : expr) : instruction list =
  let append e = append ~to_:var e in
  let bin_expr lhs rhs op =
    CCList.concat
      [ eval_pp_expr ~var lhs
      ; [ append (string (CCFormat.sprintf " %s " op)) ]
      ; eval_pp_expr ~var rhs
      ]
  in
  let instructions =
    if exists is_local_message_value e
    then
      match e with
      | Value v ->
          eval_pp_value ~var v
      | Not e ->
          CCList.concat
            [ [ append (string "(not ") ]
            ; eval_pp_expr ~var e
            ; [ append (string ")") ]
            ]
      | Arrow { condition; assertion } ->
          bin_expr condition assertion "->"
      | Cmp { lhs; op; rhs } ->
          bin_expr lhs rhs op
      | Add { lhs; op; rhs } | Mul { lhs; op; rhs } ->
          bin_expr lhs rhs (CCString.of_char op)
      | Or { lhs = And { lhs = cond; rhs = when_true }; rhs = when_false }
        when not (exists is_local_message_value cond) ->
          [ IfThenElse
              { cond
              ; then_ = eval_pp_expr ~var when_true
              ; else_ = eval_pp_expr ~var when_false
              }
          ]
      | Or { lhs; rhs } ->
          bin_expr lhs rhs "||"
      | And { lhs; rhs } ->
          bin_expr lhs rhs "&&"
      | Eq { lhs; rhs } ->
          bin_expr lhs rhs "="
      | Like { lhs; rhs } ->
          bin_expr lhs rhs "like"
      | In { el; set } ->
          bin_expr el set "in"
    else [ append e ]
  in
  combine_appends ~var instructions


let print expr = Print expr

let set prop value = Set { prop; value }

let call ?variable func args = Call { variable; call = Funcall { func; args } }

let for_each ~dataset instructions = ForEach { dataset; instructions }

let return expr = Return (Some expr)

let not e = Not e

let ite cond then_ else_ = IfThenElse { cond; then_; else_ }

let connect ?timeout ?(block = true) connection =
  Connect { connection; timeout; block }


let send ?variable ~template ~to_ ?using ?values () =
  Send { variable; template; connection = to_; using; withs = values }


let expecting ?modifier exprs = { modifier; exprs }

let receive ?variable ~from ?timeout ~where ?expecting () =
  Receive { variable; connection = from; timeout; where; expecting }


let expectingOf ~variable ~expecting = ExpectingOf { variable; expecting }

[@@@logic]
