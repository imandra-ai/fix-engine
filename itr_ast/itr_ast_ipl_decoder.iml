(* Imandra Inc. copyright 2021 *)
[@@@program]
[@@@import "itr_ast.iml"]
open Itr_ast;;
[@@@import "../src-core-pp/parse_base_types.iml"]
open Parse_base_types;;
[@@@import "../src-core-pp/parse_datetime.iml"]
open Parse_datetime;;


module My_result = struct
  type ('good, 'bad) t = ('good, 'bad) result = | Ok of 'good | Error of 'bad

  let return x = Ok x
  let map f e = match e with
    | Ok x -> Ok (f x)
    | Error s -> Error s
  let map_err f e = match e with
    | Ok _ as res -> res
    | Error y -> Error (f y)
  let flat_map f e = match e with
    | Ok x -> f x
    | Error s -> Error s

  module Infix = struct
    let (>|=) e f = map f e
    let (>>=) e f = flat_map f e
  end
end


module My_opt = struct
  let return x = Some x
  let map f = function None -> None | Some x -> Some (f x)
  let flat_map f o = match o with
    | None -> None
    | Some x -> f x
end

module My_list = struct
  let take n l =
    let rec direct i n l = match l with
      | [] -> []
      | _ when i=0 -> safe n [] l
      | x::l' ->
        if n > 0
        then x :: direct (i-1) (n-1) l'
        else []
    and safe n acc l = match l with
      | [] -> List.rev acc
      | _ when n=0 -> List.rev acc
      | x::l' -> safe (n-1) (x::acc) l'
    in
    direct 500 n l

  let map f l =
    let rec direct f i l = match l with
      | [] -> []
      | [x] -> [f x]
      | [x1;x2] -> let y1 = f x1 in [y1; f x2]
      | [x1;x2;x3] -> let y1 = f x1 in let y2 = f x2 in [y1; y2; f x3]
      | _ when i=0 -> CCList.rev (CCList.rev_map f l)
      | x1::x2::x3::x4::l' ->
        let y1 = f x1 in
        let y2 = f x2 in
        let y3 = f x3 in
        let y4 = f x4 in
        y1 :: y2 :: y3 :: y4 :: direct f (i-1) l'
    in
    direct f 500 l

  let all_some l =
    try Some (map (function Some x -> x | None -> raise Exit) l)
    with Exit -> None

  let mapi f l =
    let r = ref 0 in
    map
      (fun x ->
         let y = f !r x in
         r := !r+1; y
      ) l

  let find_map f l =
    let rec aux f = function
      | [] -> None
      | x::l' ->
        match f x with
          | Some _ as res -> res
          | None -> aux f l'
    in aux f l

  let filter_map f l =
    let rec recurse acc l = match l with
      | [] -> List.rev acc
      | x::l' ->
        let acc' = match f x with | None -> acc | Some y -> y::acc in
        recurse acc' l'
    in recurse [] l

  let fold_left = CCList.fold_left

  let direct_depth_append_ = 10_000

  let append l1 l2 =
    let rec direct i l1 l2 = match l1 with
      | [] -> l2
      | _ when i=0 -> safe l1 l2
      | x::l1' -> x :: direct (i-1) l1' l2
    and safe l1 l2 =
      CCList.rev_append (List.rev l1) l2
    in
    match l1 with
    | [] -> l2
    | [x] -> x::l2
    | [x;y] -> x::y::l2
    | _ -> direct direct_depth_append_ l1 l2

  let (@) = append

  let flat_map f l =
    let rec aux f l kont = match l with
      | [] -> kont []
      | x::l' ->
        let y = f x in
        let kont' tail = match y with
          | [] -> kont tail
          | [x] -> kont (x :: tail)
          | [x;y] -> kont (x::y::tail)
          | l -> kont (append l tail)
        in
        aux f l' kont'
    in
    aux f l (fun l->l)
end


type 'value exposed_error =
  | Decoder_error of string * 'value option
  | Decoder_errors of 'value exposed_error list
  | Decoder_tag of string * 'value exposed_error

type ('good, 'bad) result = ('good, 'bad) My_result.t = Ok of 'good | Error of 'bad

type ('value, 'a) exposed_runner_decoder = { run : 'value -> ('a, 'value exposed_error) result }


module RunnerDecoder  = struct
  type value = record_item
  let pp fmt expr = Format.fprintf fmt "@[%s@]" (Yojson.Basic.to_string @@ Itr_ast_json_pp.record_item_to_json expr)

  type error = value exposed_error

  let rec pp_error fmt = function
    | Decoder_error (msg, Some t) -> Format.fprintf fmt "@[%s, but got@ @[%a@]@]" msg pp t
    | Decoder_error (msg, None) -> Format.fprintf fmt "@[%s@]" msg
    | Decoder_errors errors ->
      let errors_trunc = My_list.take 5 errors in
      let not_shown = List.length errors - 5 in
      Format.fprintf fmt "@[%a@ %s@]"
        (Format.pp_print_list ~pp_sep:Format.pp_print_space pp_error) errors_trunc
        (if not_shown > 0 then Printf.sprintf "(...%d errors not shown...)" (Z.to_int not_shown) else "")
    | Decoder_tag (msg, error) ->
      Format.fprintf fmt "@[<2>%s:@ @[%a@]@]"
        msg
        pp_error error


      let of_file _file =

         Error "not supported"

      let get_string = function
        | Rec_value (Value (Literal (String value))) -> Some value
        | _ -> None

      let get_int = function
        | Rec_value (Value (Literal (Int value))) -> Some value
        | _ -> None

      let get_float = function
        | Rec_value (Value (Literal (Float value))) -> Some value
        | Rec_value (Value (Literal (Int value))) -> Some (Q.of_bigint value)
        | _ -> None

      let get_bool = function
        |  Rec_value (Value (Literal (Bool value))) -> Some value
        | _ -> None

      let get_null = function
        | _ -> None

      let get_list : value -> value list option = function
       (* | `List l -> Some l *)
        | _ -> None
    (* use this as record assoc?*)
      let get_key_value_pairs : value -> (value * value) list option = function
      (*   | `Assoc assoc -> Some (List.map (fun (key, value) -> (`String key, value)) assoc) *)
        | _ -> None

      let to_list values = Rec_value (Value (Literal LiteralNone))

  let string_of_error e : string =
    Format.asprintf "@[<2>%a@?@]" pp_error e

  let tag_error (msg : string) (error : error) : error =
    Decoder_tag (msg, error)

  let tag_errors (msg : string) (errors : error list) : error =
    Decoder_tag (msg, Decoder_errors errors)

  let merge_errors e1 e2 =
    match e1, e2 with
    | Decoder_errors e1s, Decoder_errors e2s -> Decoder_errors (e1s @ e2s)
    | Decoder_errors e1s, _ -> Decoder_errors (e1s @ [e2])
    | _, Decoder_errors e2s -> Decoder_errors ([e1] @ e2s )
    | _ -> Decoder_errors [e1; e2]

  let combine_errors (results : ('a, error) result list) : ('a list, error list) result =
    let rec aux combined =
      function
      | [] ->
        (match combined with
         | Ok xs -> Ok (List.rev xs)
         | Error es -> Error (List.rev es))
      | result :: rest ->
        let combined =
          match result, combined with
          | Ok x, Ok xs -> Ok (x :: xs)
          | Error e, Error es -> Error (e :: es)
          | Error e, Ok _ -> Error [e]
          | Ok _, Error es -> Error es
        in
        aux combined rest
    in
    aux (Ok []) results

  (* let of_string : string -> (value, error) result =
    fun string ->
    of_string string
    |> My_result.map_err (fun msg ->
        (Decoder_tag ("Json parse error", Decoder_error (msg, None)))
      ) *)

  type 'a runner_decoder = (value, 'a) exposed_runner_decoder

  let succeed x =
    { run = fun _ -> Ok x }

  let fail msg =
    { run = fun input -> Error (Decoder_error (msg, Some input)) }

  let fail_with error =
    { run = fun _ -> Error error }

  let from_result = function
    | Ok ok -> succeed ok
    | Error error -> fail_with error

  let value =
    { run = fun input -> Ok input }

  let map f runner_decoder =
    { run = fun input -> My_result.Infix.(runner_decoder.run input >|= f) }

  let apply : ('a -> 'b) runner_decoder -> 'a runner_decoder -> 'b runner_decoder =
    fun f runner_decoder ->
    { run =
        fun input ->
          match f.run input, runner_decoder.run input with
          | Error e1, Error e2 -> Error (merge_errors e1 e2)
          | Error e, _ -> Error e
          | _, Error e -> Error e
          | Ok g, Ok x -> Ok (g x)
    }

  let and_then (f : 'a -> 'b runner_decoder) (runner_decoder : 'a runner_decoder) : 'b runner_decoder =
    { run = fun input ->
          My_result.Infix.(
            runner_decoder.run input >>= fun result ->
            (f result).run input)
    }

  let fix (f : 'a runner_decoder -> 'a runner_decoder) : 'a runner_decoder =
    let rec p = lazy (f r)
    and r = { run = fun value -> (Lazy.force p).run value }
    in
    r

  module Infix = struct
    let (>|=) x f = map f x
    let (>>=) x f = and_then f x
    let (<*>) f x = apply f x
    let (let*) = (>>=)
    let (let+) = (>|=)
  end

  let maybe (runner_decoder : 'a runner_decoder) : 'a option runner_decoder =
    { run = fun input ->
          match (runner_decoder.run input) with
          | Ok result -> Ok (Some result)
          | Error _ -> Ok None
    }

  let nullable (runner_decoder : 'a runner_decoder) : 'a option runner_decoder =
    { run =
        fun input ->
          match get_null input with
          | Some () -> Ok None
          | None ->
            runner_decoder.run input
            |> My_result.map My_opt.return
            |> My_result.map_err (tag_error "Expected null or")
    }

  let one_of : (string * 'a runner_decoder) list -> 'a runner_decoder =
    fun runner_decoders ->
    let run input =
      let rec go errors = function
        | (name, runner_decoder) :: rest ->
          (match runner_decoder.run input with
           | Ok result -> Ok result
           | Error error -> go (tag_errors (Printf.sprintf "%S runner_decoder" name) [ error ] :: errors) rest)
        | [] ->
          Error
            (tag_errors "I tried the following runner_decoders but they all failed" errors)
      in
      go [] runner_decoders
    in { run }

  let primitive_runner_decoder (get_value : value -> 'a option) (message : string) : 'a runner_decoder =
    { run =
        fun t ->
          match get_value t with
          | Some value -> Ok value
          | _ -> (fail message).run t
    }

  let string : string runner_decoder =
    primitive_runner_decoder get_string "Expected a string"

  let int : Z.t runner_decoder =
    primitive_runner_decoder get_int "Expected an int"

  let float : real runner_decoder =
    primitive_runner_decoder get_float "Expected a float"

  let bool : bool runner_decoder =
    primitive_runner_decoder get_bool "Expected a bool"

  let null : unit runner_decoder =
    primitive_runner_decoder get_null "Expected a null"

  let list : 'a runner_decoder -> 'a list runner_decoder =
    fun runner_decoder ->
    { run =
        fun t ->
          match get_list t with
          | None -> (fail "Expected a list").run t
          | Some values ->
            values
            |> My_list.mapi (fun i x ->
                runner_decoder.run x
                |> My_result.map_err
                  (tag_error (Printf.sprintf "element %i" (Z.to_int i)))
              )
            |> combine_errors
            |> My_result.map_err
              (tag_errors "while decoding a list")
    }

  let list_filter : 'a option runner_decoder -> 'a list runner_decoder =
    fun runner_decoder ->
    let rec go i = function
      | [] -> Ok []
      | v :: vs ->
        My_result.Infix.(
          runner_decoder.run v
          |> My_result.map_err
            (tag_error (Printf.sprintf "element %i" (Z.to_int i))) >>= function
          | Some x ->
            go (i + 1) vs >>= fun xs ->
            My_result.return (x :: xs)
          | None -> go (i + 1) vs
        )
    in
    { run =
        fun t ->
          match get_list t with
          | None -> (fail "Expected a list").run t
          | Some values ->
            go 0 values
            |> My_result.map_err (tag_error "while decoding a list")
    }

  let list_fold_left : ('a -> 'a runner_decoder) -> 'a -> 'a runner_decoder =
    fun runner_decoder_func init ->
    {
      run =
        fun t ->
          match get_list t with
          | None -> (fail "Expected a list").run t
          | Some values ->
            values
            |> My_result.Infix.(My_list.fold_left (fun (acc,i) el ->
                (acc >>= fun acc ->
                 (acc |> runner_decoder_func).run el
                 |> My_result.map_err (tag_error (Printf.sprintf "element %i" i))),Z.to_int ((Z.of_int i)+1))
              )  (Ok init,0i) |> fst
            |> My_result.map_err (tag_error "while decoding a list")
    }

  let field : string -> 'a runner_decoder -> 'a runner_decoder =
    fun key value_runner_decoder ->
    { run =
        fun t ->
          let value =
            get_key_value_pairs t
            |> My_opt.flat_map (My_list.find_map (fun (k, v) ->
                match get_string k with
                | Some s when s = key -> Some v
                | _ -> None
              ))
          in
          match value with
          | Some value ->
            value_runner_decoder.run value
            |> My_result.map_err (tag_error (Printf.sprintf "in field %S" key))
          | None -> (fail (Printf.sprintf "Expected an object with an attribute %S" key)).run t
    }

  let field_opt : string -> 'a runner_decoder -> 'a option runner_decoder =
    fun key value_runner_decoder ->
    { run =
        fun t ->
          let value =
            get_key_value_pairs t
            |> My_opt.flat_map (My_list.find_map (fun (k, v) ->
                match get_string k with
                | Some s when s = key -> Some v
                | _ -> None
              ))
          in
          match value with
          | Some value ->
            value_runner_decoder.run value
            |> My_result.map (fun v -> Some v)
            |> My_result.map_err (tag_error (Printf.sprintf "in field %S" key))
          | None -> Ok None
    }

  let single_field : (string -> 'a runner_decoder) -> 'a runner_decoder =
    fun value_runner_decoder ->
    { run =
        fun t ->
          match get_key_value_pairs t with
          | Some [(key, value)] ->
            begin match get_string key with
              | Some key ->
                (value_runner_decoder key).run value
                |> My_result.map_err (tag_error (Printf.sprintf "in field %S" key))
              | None -> (fail "Expected an object with a string key").run t
            end
          | _ -> (fail "Expected an object with a single attribute").run t
    }

  let index : int -> 'a runner_decoder -> 'a runner_decoder =
    fun i runner_decoder ->
    { run =
        fun t ->
          match get_list t with
          | Some l ->
            let item = List.nth i l
            in
            begin match item with
              | None -> (fail ("expected a list with at least " ^  (Z.to_string i) ^ " elements")).run t
              | Some item -> runner_decoder.run item
            end
          | None -> (fail "Expected a list").run t
    }

  let uncons (tail : 'a -> 'b runner_decoder) (head : 'a runner_decoder) : 'b runner_decoder =
    { run =
        fun value ->
          match get_list value with
        | Some (x :: rest) ->
          My_result.Infix.(
            head.run x
            |> My_result.map_err (tag_error "while consuming a list element")
            >>= fun x ->
            (tail x).run (to_list rest)
            |> My_result.map_err (tag_error "after consuming a list element")
          )
        | Some [] -> (fail "Expected a non-empty list").run value
        | None -> (fail "Expected a list").run value
    }

  let rec at : string list -> 'a runner_decoder -> 'a runner_decoder = fun path runner_decoder ->
    match path with
    | [key] -> field key runner_decoder
    | key :: rest -> field key (at rest runner_decoder)
    | [] -> fail "Must provide at least one key to 'at'"

  let keys' : 'k runner_decoder -> 'k list runner_decoder =
    fun key_runner_decoder ->
    { run =
        fun value ->
          match get_key_value_pairs value with
          | Some assoc ->
            assoc
            |> List.map (fun (key, _) -> key_runner_decoder.run key)
            |> combine_errors
            |> My_result.map_err
              (tag_errors "Failed while decoding the keys of an object")
          | None -> (fail "Expected an object").run value
    }

  let keys = keys' string

  let key_value_pairs' : 'k runner_decoder -> 'v runner_decoder -> ('k * 'v) list runner_decoder =
    fun key_runner_decoder value_runner_decoder ->
    { run =
        fun value ->
          match get_key_value_pairs value with
          | Some assoc ->
            assoc
            |> List.map
              My_result.Infix.(fun (key_val, value_val) ->
                  key_runner_decoder.run key_val >>= fun key ->
                  value_runner_decoder.run value_val >|= fun value ->
                  (key, value)
                )
            |> combine_errors
            |> My_result.map_err
              (tag_errors "Failed while decoding key-value pairs")
          | None -> (fail "Expected an object").run value
    }

  let key_value_pairs value_runner_decoder = key_value_pairs' string value_runner_decoder

  let key_value_pairs_seq' : 'k runner_decoder -> ('k -> 'v runner_decoder) -> 'v list runner_decoder =
    fun key_runner_decoder value_runner_decoder ->
    { run =
        fun value ->
          match get_key_value_pairs value with
          | Some assoc ->
            assoc
            |> List.map
              My_result.Infix.(fun (key_val, value_val) ->
                  key_runner_decoder.run key_val >>= fun key ->
                  (value_runner_decoder key).run value_val
                )
            |> combine_errors
            |> My_result.map_err
              (tag_errors "Failed while decoding key-value pairs")
          | None -> (fail "Expected an object").run value
    }

  let key_value_pairs_seq value_runner_decoder = key_value_pairs_seq' string value_runner_decoder

  let decode_value (runner_decoder : 'a runner_decoder) (input : value) : ('a, error) result =
    runner_decoder.run input

  module Pipeline = struct
    let decode = succeed

    let custom : 'a runner_decoder -> ('a -> 'b) runner_decoder -> 'b runner_decoder =
      fun customDecoder next ->
      apply next customDecoder

    let required : string -> 'a runner_decoder -> ('a -> 'b) runner_decoder -> 'b runner_decoder =
      fun key runner_decoder next ->
      custom (field key runner_decoder) next

    let required_at : string list -> 'a runner_decoder -> ('a -> 'b) runner_decoder -> 'b runner_decoder =
      fun path runner_decoder next ->
      custom (at path runner_decoder) next

    let optional_runner_decoder : value runner_decoder -> 'a runner_decoder -> 'a -> 'a runner_decoder =
      fun path_runner_decoder val_runner_decoder default ->
      let null_or runner_decoder =
        one_of
          [ ( "non-null", runner_decoder )
          ; ( "null", null |> map (fun () -> default) )
          ] in
      let handle_result : value -> 'a runner_decoder =
        fun input ->
          match decode_value path_runner_decoder input with
          | Ok rawValue ->
            (* The field was present. *)
            decode_value (null_or val_runner_decoder) rawValue
            |> from_result
          | Error _ ->
            (* The field was not present. *)
            succeed default
      in
      value |> and_then handle_result

    let optional : string -> 'a runner_decoder -> 'a -> ('a -> 'b) runner_decoder -> 'b runner_decoder =
      fun key val_runner_decoder default next ->
      custom (optional_runner_decoder (field key value) val_runner_decoder default) next

    let optional_at : string list -> 'a runner_decoder -> 'a -> ('a -> 'b) runner_decoder -> 'b runner_decoder =
      fun path val_runner_decoder default next ->
      custom (optional_runner_decoder (at path value) val_runner_decoder default) next
  end

  include Infix
end

[@@@logic]