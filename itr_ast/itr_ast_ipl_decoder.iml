(* Imandra Inc. copyright 2021 *)
[@@@program]

[@@@import "itr_ast.iml"]

open Itr_ast

[@@@import "../src-core-pp/parse_base_types.iml"]

open Parse_base_types

[@@@import "../src-core-pp/parse_datetime.iml"]

open Parse_datetime

(* This decoder stucture is based on the decoders and decoders-yojson project *)
(* written by Matt Bray here https://mattjbray.github.io/ocaml-decoders/      *)

type 'value exposed_error =
  | Decoder_error of string * 'value option
  | Decoder_errors of 'value exposed_error list
  | Decoder_tag of string * 'value exposed_error

type ('good, 'bad) result = ('good, 'bad) CCResult.t =
  | Ok of 'good
  | Error of 'bad

type ('value, 'a) exposed_runner_decoder =
  { run : 'value -> ('a, 'value exposed_error) result }

type value = record_item

let pp fmt expr =
  Format.fprintf
    fmt
    "@[%s@]"
    (Yojson.Basic.to_string @@ Itr_ast_json_pp.record_item_to_json expr)


type error = value exposed_error

let rec pp_error fmt = function
  | Decoder_error (msg, Some t) ->
      Format.fprintf fmt "@[%s, but got@ @[%a@]@]" msg pp t
  | Decoder_error (msg, None) ->
      Format.fprintf fmt "@[%s@]" msg
  | Decoder_errors errors ->
      let errors_trunc = CCList.take 5i errors in
      let not_shown = List.length errors - 5 in
      Format.fprintf
        fmt
        "@[%a@ %s@]"
        (Format.pp_print_list ~pp_sep:Format.pp_print_space pp_error)
        errors_trunc
        ( if not_shown > 0
        then Printf.sprintf "(...%d errors not shown...)" (Z.to_int not_shown)
        else "" )
  | Decoder_tag (msg, error) ->
      Format.fprintf fmt "@[<2>%s:@ @[%a@]@]" msg pp_error error


let of_file _file = Error "not supported"

let runner_none = Rec_value (Value (Literal LiteralNone))

let get_string = function
  | Rec_value (Value (Literal (String value))) ->
      Some value
  | _ ->
      None


let get_lstring = function
  | Rec_value (Value (Literal (String value))) ->
      Some (LString.of_string value)
  | _ ->
      None


let get_int = function
  | Rec_value (Value (Literal (Int value))) ->
      Some value
  | _ ->
      None


let get_float = function
  | Rec_value (Value (Literal (Float s))) ->
      parse_float (Real.to_string_approx s)
  | Rec_value (Value (Literal (Int s))) ->
      parse_float (Z.to_string s ^ ".0")
  | _ ->
      None


let get_bool = function
  | Rec_value (Value (Literal (Bool value))) ->
      Some value
  | _ ->
      None


let get_opt : value -> value option = function
  | Rec_value (Value (Literal LiteralNone)) ->
      Some runner_none
  | Rec_value (Value (Literal (LiteralSome value))) ->
      Some value
  | _ ->
      None


let get_null = function _ -> None

let get_list : value -> value list option = function
  | Rec_value (Value (Literal (Coll values))) ->
      Some values
  | _ ->
      None


let get_set : value -> value Set.t option = function
  | Rec_value (Value (Literal (Coll values))) ->
      Some (Set.of_list values)
  | _ ->
      None


let get_map : value -> (value, value) Map.t option = function
  | Rec_value (Value (Literal (MapColl (def, values)))) ->
      Some (Map.of_list ~default:def values)
  | _ ->
      None


let get_key_value_pairs : value -> (value * value) list option = function
  | Rec_record { elements; _ } ->
      Some
        (List.map
           (fun (key, value) ->
             (Rec_value (Value (Literal (String key))), value) )
           (String_map.to_list elements) )
  | _ ->
      None


let get_utctimestamp = function
  | Rec_value (Value (Literal (Datetime (UTCTimestamp s)))) ->
      Some s
  | _ ->
      None


let get_utctimeonly = function
  | Rec_value (Value (Literal (Datetime (UTCTimeOnly s)))) ->
      Some s
  | _ ->
      None


let get_utcdateonly = function
  | Rec_value (Value (Literal (Datetime (UTCDateOnly s)))) ->
      Some s
  | _ ->
      None


let get_monthyear = function
  | Rec_value (Value (Literal (Datetime (MonthYear s)))) ->
      Some s
  | _ ->
      None


let get_localmktdate = function
  | Rec_value (Value (Literal (Datetime (LocalMktDate s)))) ->
      Some s
  | _ ->
      None


let get_duration = function
  | Rec_value (Value (Literal (Datetime (Duration s)))) ->
      Some s
  | _ ->
      None


let to_list values = Rec_value (Value (Literal (Coll values)))

let string_of_error e : string = Format.asprintf "@[<2>%a@?@]" pp_error e

let tag_error (msg : string) (error : error) : error = Decoder_tag (msg, error)

let tag_errors (msg : string) (errors : error list) : error =
  Decoder_tag (msg, Decoder_errors errors)


let merge_errors e1 e2 =
  match (e1, e2) with
  | Decoder_errors e1s, Decoder_errors e2s ->
      Decoder_errors (e1s @ e2s)
  | Decoder_errors e1s, _ ->
      Decoder_errors (e1s @ [ e2 ])
  | _, Decoder_errors e2s ->
      Decoder_errors ([ e1 ] @ e2s)
  | _ ->
      Decoder_errors [ e1; e2 ]


let combine_map_el_error
    (keys : ('a, error) result list)
    (values : ('b, error) result list)
    (def : ('b, error) result) : (('a * 'b) list * 'b, error list) result =
  let rec aux combined keys values =
    match (keys, values) with
    | [], [] ->
      ( match combined with
      | Ok (xs, def) ->
          Ok (List.rev xs, def)
      | Error es ->
          Error (List.rev es) )
    | key :: keys_rest, value :: values_rest ->
        let combined =
          match (key, value, combined) with
          | Ok k, Ok v, Ok (xs, def) ->
              Ok ((k, v) :: xs, def)
          | Error ek, Error ev, Error es ->
              Error (ek :: ev :: es)
          | _, Error ev, Error es ->
              Error (ev :: es)
          | Error ek, _, Error es ->
              Error (ek :: es)
          | Ok _, Ok _, Error es ->
              Error es
          | Error ek, Error ev, Ok _ ->
              Error [ ek; ev ]
          | Error ek, _, Ok _ ->
              Error [ ek ]
          | _, Error ev, Ok _ ->
              Error [ ev ]
        in
        aux combined keys_rest values_rest
    | _ ->
        Error
          [ Decoder_error
              ("Inconsistent map and key value element numbers in map.", None)
          ]
  in
  match def with
  | Ok def ->
      aux (Ok ([], def)) keys values
  | Error e ->
      aux (Error [ e ]) keys values


let combine_errors (results : ('a, error) result list) :
    ('a list, error list) result =
  let rec aux combined = function
    | [] ->
      ( match combined with
      | Ok xs ->
          Ok (List.rev xs)
      | Error es ->
          Error (List.rev es) )
    | result :: rest ->
        let combined =
          match (result, combined) with
          | Ok x, Ok xs ->
              Ok (x :: xs)
          | Error e, Error es ->
              Error (e :: es)
          | Error e, Ok _ ->
              Error [ e ]
          | Ok _, Error es ->
              Error es
        in
        aux combined rest
  in
  aux (Ok []) results


type 'a runner_decoder = (value, 'a) exposed_runner_decoder

let succeed x = { run = (fun _ -> Ok x) }

let fail msg = { run = (fun input -> Error (Decoder_error (msg, Some input))) }

let fail_with error = { run = (fun _ -> Error error) }

let from_result = function
  | Ok ok ->
      succeed ok
  | Error error ->
      fail_with error


let value = { run = (fun input -> Ok input) }

let map f runner_decoder =
  { run = (fun input -> CCResult.Infix.(runner_decoder.run input >|= f)) }


let apply : ('a -> 'b) runner_decoder -> 'a runner_decoder -> 'b runner_decoder
    =
 fun f runner_decoder ->
  { run =
      (fun input ->
        match (f.run input, runner_decoder.run input) with
        | Error e1, Error e2 ->
            Error (merge_errors e1 e2)
        | Error e, _ ->
            Error e
        | _, Error e ->
            Error e
        | Ok g, Ok x ->
            Ok (g x) )
  }


let and_then (f : 'a -> 'b runner_decoder) (runner_decoder : 'a runner_decoder)
    : 'b runner_decoder =
  { run =
      (fun input ->
        CCResult.Infix.(
          runner_decoder.run input >>= fun result -> (f result).run input) )
  }


let fix (f : 'a runner_decoder -> 'a runner_decoder) : 'a runner_decoder =
  let rec p = lazy (f r)
  and r = { run = (fun value -> (Lazy.force p).run value) } in
  r


module Infix = struct
  let ( >|= ) x f = map f x

  let ( >>= ) x f = and_then f x

  let ( <*> ) f x = apply f x

  let ( let* ) = ( >>= )

  let ( let+ ) = ( >|= )
end

let maybe (runner_decoder : 'a runner_decoder) : 'a option runner_decoder =
  { run =
      (fun input ->
        match runner_decoder.run input with
        | Ok result ->
            Ok (Some result)
        | Error _ ->
            Ok None )
  }


let nullable (runner_decoder : 'a runner_decoder) : 'a option runner_decoder =
  { run =
      (fun input ->
        match get_null input with
        | Some () ->
            Ok None
        | None ->
            runner_decoder.run input
            |> CCResult.map CCOpt.return
            |> CCResult.map_err (tag_error "Expected null or") )
  }


let one_of : (string * 'a runner_decoder) list -> 'a runner_decoder =
 fun runner_decoders ->
  let run input =
    let rec go errors = function
      | (name, runner_decoder) :: rest ->
        ( match runner_decoder.run input with
        | Ok result ->
            Ok result
        | Error error ->
            go
              ( tag_errors (Printf.sprintf "%S runner_decoder" name) [ error ]
              :: errors )
              rest )
      | [] ->
          Error
            (tag_errors
               "I tried the following runner_decoders but they all failed"
               errors )
    in
    go [] runner_decoders
  in
  { run }


let primitive_runner_decoder (get_value : value -> 'a option) (message : string)
    : 'a runner_decoder =
  { run =
      (fun t ->
        match get_value t with
        | Some value ->
            Ok value
        | _ ->
            (fail message).run t )
  }


let string : string runner_decoder =
  primitive_runner_decoder get_string "Expected a string"


let lstring : LString.t runner_decoder =
  primitive_runner_decoder get_lstring "Expected a string"


let int : Z.t runner_decoder =
  primitive_runner_decoder get_int "Expected an int"


let float : Numeric.fix_float_6 runner_decoder =
  primitive_runner_decoder get_float "Expected a float"


let float_0 : Numeric.fix_float_0 runner_decoder =
  let open Infix in
  float >|= Numeric.float_Convert_6_0


let float_1 : Numeric.fix_float_1 runner_decoder =
  let open Infix in
  float >|= Numeric.float_Convert_6_1


let float_2 : Numeric.fix_float_2 runner_decoder =
  let open Infix in
  float >|= Numeric.float_Convert_6_2


let float_3 : Numeric.fix_float_3 runner_decoder =
  let open Infix in
  float >|= Numeric.float_Convert_6_3


let float_4 : Numeric.fix_float_4 runner_decoder =
  let open Infix in
  float >|= Numeric.float_Convert_6_4


let float_5 : Numeric.fix_float_5 runner_decoder =
  let open Infix in
  float >|= Numeric.float_Convert_6_5


let float_6 : Numeric.fix_float_6 runner_decoder = float

let bool : bool runner_decoder =
  primitive_runner_decoder get_bool "Expected a bool"


let utctimestamp : Datetime.fix_utctimestamp_micro runner_decoder =
  primitive_runner_decoder get_utctimestamp "Expected a UTCTimestamp"


let utctimestamp_milli : Datetime.fix_utctimestamp_milli runner_decoder =
  let open Infix in
  utctimestamp >|= Datetime.convert_utctimestamp_micro_milli


let utctimestamp_micro : Datetime.fix_utctimestamp_micro runner_decoder =
  utctimestamp


let utctimeonly : Datetime.fix_utctimeonly_micro runner_decoder =
  primitive_runner_decoder get_utctimeonly "Expected a UTCTimeonly"


let utctimeonly_milli : Datetime.fix_utctimeonly_milli runner_decoder =
  let open Infix in
  utctimeonly >|= Datetime.convert_utctimeonly_micro_milli


let utctimeonly_micro : Datetime.fix_utctimeonly_micro runner_decoder =
  utctimeonly


let utcdateonly : Datetime.fix_utcdateonly runner_decoder =
  primitive_runner_decoder get_utcdateonly "Expected a UTCDateonly"


let monthyear : Datetime.fix_monthyear runner_decoder =
  primitive_runner_decoder get_monthyear "Expected a Monthyear"


let localmktdate : Datetime.fix_localmktdate runner_decoder =
  primitive_runner_decoder get_localmktdate "Expected a LocalMktDate"


let duration : Datetime.fix_duration runner_decoder =
  primitive_runner_decoder get_duration "Expected a Duration"


let null : unit runner_decoder =
  primitive_runner_decoder get_null "Expected a null"


let opt : 'a runner_decoder -> 'a option runner_decoder =
 fun runner_decoder ->
  { run =
      (fun t ->
        match get_opt t with
        | None ->
            (fail "Expected on opt").run t
        | Some value ->
            if value = runner_none
            then Ok None
            else
              let open CCResult in
              runner_decoder.run value
              |> CCResult.map_err (tag_error (Printf.sprintf "opt element"))
              >|= fun x -> Some x )
  }


let set : 'a runner_decoder -> 'a Set.t runner_decoder =
 fun runner_decoder ->
  { run =
      (fun t ->
        match get_set t with
        | None ->
            (fail "Expected a set").run t
        | Some values ->
            let open CCResult in
            CCList.mapi
              (fun i x ->
                runner_decoder.run x
                |> CCResult.map_err (tag_error (Printf.sprintf "element %i" i))
                )
              (Set.to_list values)
            |> combine_errors
            |> CCResult.map_err (tag_errors "while decoding a set")
            >|= Set.of_list )
  }


let mapf :
    'a runner_decoder -> 'b runner_decoder -> ('a, 'b) Map.t runner_decoder =
 fun key_runner_decoder value_runner_decoder ->
  { run =
      (fun t ->
        match get_map t with
        | None ->
            (fail "Expected a map").run t
        | Some values ->
            let open CCResult in
            let values, def = Map.extract values in
            let def =
              value_runner_decoder.run def
              |> CCResult.map_err (tag_error (Printf.sprintf "default value"))
            in
            let key_list =
              CCList.mapi
                (fun i k ->
                  key_runner_decoder.run k
                  |> CCResult.map_err
                       (tag_error (Printf.sprintf "key element %i" i)) )
                (List.map fst values)
            in
            let value_list =
              CCList.mapi
                (fun i v ->
                  value_runner_decoder.run v
                  |> CCResult.map_err
                       (tag_error (Printf.sprintf "key element %i" i)) )
                (List.map snd values)
            in
            combine_map_el_error key_list value_list def
            |> CCResult.map_err (tag_errors "while decoding a map")
            >|= fun (els, default) -> Map.of_list ~default els )
  }


let list : 'a runner_decoder -> 'a list runner_decoder =
 fun runner_decoder ->
  { run =
      (fun t ->
        match get_list t with
        | None ->
            (fail "Expected a list").run t
        | Some values ->
            values
            |> CCList.mapi (fun i x ->
                   runner_decoder.run x
                   |> CCResult.map_err
                        (tag_error (Printf.sprintf "element %i" i)) )
            |> combine_errors
            |> CCResult.map_err (tag_errors "while decoding a list") )
  }


let list_filter : 'a option runner_decoder -> 'a list runner_decoder =
 fun runner_decoder ->
  let rec go i = function
    | [] ->
        Ok []
    | v :: vs ->
        CCResult.Infix.(
          runner_decoder.run v
          |> CCResult.map_err
               (tag_error (Printf.sprintf "element %i" (Z.to_int i)))
          >>= (function
          | Some x ->
              go (i + 1) vs >>= fun xs -> CCResult.return (x :: xs)
          | None ->
              go (i + 1) vs ))
  in
  { run =
      (fun t ->
        match get_list t with
        | None ->
            (fail "Expected a list").run t
        | Some values ->
            go 0 values |> CCResult.map_err (tag_error "while decoding a list")
        )
  }


let list_fold_left : ('a -> 'a runner_decoder) -> 'a -> 'a runner_decoder =
 fun runner_decoder_func init ->
  { run =
      (fun t ->
        match get_list t with
        | None ->
            (fail "Expected a list").run t
        | Some values ->
            values
            |> CCResult.Infix.(
                 CCList.fold_left (fun (acc, i) el ->
                     ( ( acc
                       >>= fun acc ->
                       (acc |> runner_decoder_func).run el
                       |> CCResult.map_err
                            (tag_error (Printf.sprintf "element %i" i)) )
                     , Z.to_int (Z.of_int i + 1) ) ))
                 (Ok init, 0i)
            |> fst
            |> CCResult.map_err (tag_error "while decoding a list") )
  }


let field : string -> 'a runner_decoder -> 'a runner_decoder =
 fun key value_runner_decoder ->
  { run =
      (fun t ->
        let value =
          get_key_value_pairs t
          |> CCOpt.flat_map
               (CCList.find_map (fun (k, v) ->
                    match get_string k with
                    | Some s when s = key ->
                        Some v
                    | _ ->
                        None ) )
        in
        match value with
        | Some value ->
            value_runner_decoder.run value
            |> CCResult.map_err (tag_error (Printf.sprintf "in field %S" key))
        | None ->
            (fail
               (Printf.sprintf "Expected an object with an attribute %S" key) )
              .run
              t )
  }


let field_opt : string -> 'a runner_decoder -> 'a option runner_decoder =
 fun key value_runner_decoder ->
  { run =
      (fun t ->
        let value =
          get_key_value_pairs t
          |> CCOpt.flat_map
               (CCList.find_map (fun (k, v) ->
                    match get_string k with
                    | Some s when s = key ->
                        Some v
                    | _ ->
                        None ) )
        in
        match value with
        | Some value ->
            value_runner_decoder.run value
            |> CCResult.map (fun v -> Some v)
            |> CCResult.map_err (tag_error (Printf.sprintf "in field %S" key))
        | None ->
            Ok None )
  }


let single_field : (string -> 'a runner_decoder) -> 'a runner_decoder =
 fun value_runner_decoder ->
  { run =
      (fun t ->
        match get_key_value_pairs t with
        | Some [ (key, value) ] ->
          ( match get_string key with
          | Some key ->
              (value_runner_decoder key).run value
              |> CCResult.map_err (tag_error (Printf.sprintf "in field %S" key))
          | None ->
              (fail "Expected an object with a string key").run t )
        | _ ->
            (fail "Expected an object with a single attribute").run t )
  }


let index : int -> 'a runner_decoder -> 'a runner_decoder =
 fun i runner_decoder ->
  { run =
      (fun t ->
        match get_list t with
        | Some l ->
            let item = List.nth i l in
            ( match item with
            | None ->
                (fail
                   ( "expected a list with at least "
                   ^ Z.to_string i
                   ^ " elements" ) )
                  .run
                  t
            | Some item ->
                runner_decoder.run item )
        | None ->
            (fail "Expected a list").run t )
  }


let uncons (tail : 'a -> 'b runner_decoder) (head : 'a runner_decoder) :
    'b runner_decoder =
  { run =
      (fun value ->
        match get_list value with
        | Some (x :: rest) ->
            CCResult.Infix.(
              head.run x
              |> CCResult.map_err (tag_error "while consuming a list element")
              >>= fun x ->
              (tail x).run (to_list rest)
              |> CCResult.map_err (tag_error "after consuming a list element"))
        | Some [] ->
            (fail "Expected a non-empty list").run value
        | None ->
            (fail "Expected a list").run value )
  }


let rec at : string list -> 'a runner_decoder -> 'a runner_decoder =
 fun path runner_decoder ->
  match path with
  | [ key ] ->
      field key runner_decoder
  | key :: rest ->
      field key (at rest runner_decoder)
  | [] ->
      fail "Must provide at least one key to 'at'"


let keys' : 'k runner_decoder -> 'k list runner_decoder =
 fun key_runner_decoder ->
  { run =
      (fun value ->
        match get_key_value_pairs value with
        | Some assoc ->
            assoc
            |> List.map (fun (key, _) -> key_runner_decoder.run key)
            |> combine_errors
            |> CCResult.map_err
                 (tag_errors "Failed while decoding the keys of an object")
        | None ->
            (fail "Expected an object").run value )
  }


let keys = keys' string

let key_value_pairs' :
    'k runner_decoder -> 'v runner_decoder -> ('k * 'v) list runner_decoder =
 fun key_runner_decoder value_runner_decoder ->
  { run =
      (fun value ->
        match get_key_value_pairs value with
        | Some assoc ->
            assoc
            |> CCList.map
                 CCResult.Infix.(
                   fun (key_val, value_val) ->
                     key_runner_decoder.run key_val
                     >>= fun key ->
                     value_runner_decoder.run value_val
                     >|= fun value -> (key, value))
            |> combine_errors
            |> CCResult.map_err
                 (tag_errors "Failed while decoding key-value pairs")
        | None ->
            (fail "Expected an object").run value )
  }


let key_value_pairs value_runner_decoder =
  key_value_pairs' string value_runner_decoder


let key_value_pairs_seq' :
    'k runner_decoder -> ('k -> 'v runner_decoder) -> 'v list runner_decoder =
 fun key_runner_decoder value_runner_decoder ->
  { run =
      (fun value ->
        match get_key_value_pairs value with
        | Some assoc ->
            assoc
            |> CCList.map
                 CCResult.Infix.(
                   fun (key_val, value_val) ->
                     key_runner_decoder.run key_val
                     >>= fun key -> (value_runner_decoder key).run value_val)
            |> combine_errors
            |> CCResult.map_err
                 (tag_errors "Failed while decoding key-value pairs")
        | None ->
            (fail "Expected an object").run value )
  }


let key_value_pairs_seq value_runner_decoder =
  key_value_pairs_seq' string value_runner_decoder


let decode_value (runner_decoder : 'a runner_decoder) (input : value) :
    ('a, error) result =
  runner_decoder.run input


module Pipeline = struct
  let decode = succeed

  let custom :
      'a runner_decoder -> ('a -> 'b) runner_decoder -> 'b runner_decoder =
   fun customDecoder next -> apply next customDecoder


  let required :
         string
      -> 'a runner_decoder
      -> ('a -> 'b) runner_decoder
      -> 'b runner_decoder =
   fun key runner_decoder next -> custom (field key runner_decoder) next


  let required_at :
         string list
      -> 'a runner_decoder
      -> ('a -> 'b) runner_decoder
      -> 'b runner_decoder =
   fun path runner_decoder next -> custom (at path runner_decoder) next


  let optional_runner_decoder :
      value runner_decoder -> 'a runner_decoder -> 'a -> 'a runner_decoder =
   fun path_runner_decoder val_runner_decoder default ->
    let null_or runner_decoder =
      one_of
        [ ("non-null", runner_decoder)
        ; ("null", null |> map (fun () -> default))
        ]
    in
    let handle_result : value -> 'a runner_decoder =
     fun input ->
      match decode_value path_runner_decoder input with
      | Ok rawValue ->
          (* The field was present. *)
          decode_value (null_or val_runner_decoder) rawValue |> from_result
      | Error _ ->
          (* The field was not present. *)
          succeed default
    in
    value |> and_then handle_result


  let optional :
         string
      -> 'a runner_decoder
      -> 'a
      -> ('a -> 'b) runner_decoder
      -> 'b runner_decoder =
   fun key val_runner_decoder default next ->
    custom
      (optional_runner_decoder (field key value) val_runner_decoder default)
      next


  let optional_at :
         string list
      -> 'a runner_decoder
      -> 'a
      -> ('a -> 'b) runner_decoder
      -> 'b runner_decoder =
   fun path val_runner_decoder default next ->
    custom
      (optional_runner_decoder (at path value) val_runner_decoder default)
      next
end

include Infix

[@@@logic]
